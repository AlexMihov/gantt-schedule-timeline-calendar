{"version":3,"file":"ItemMovement.plugin.js","sources":["../src/plugins/ItemMovement.plugin.js"],"sourcesContent":["/**\n * Gantt-Schedule-Timeline-Calendar\n *\n * @copyright Rafal Pospiech <https://neuronet.io>\n * @author    Rafal Pospiech <neuronet.io@gmail.com>\n * @package   gantt-schedule-timeline-calendar\n * @license   GPL-3.0\n */\n\n// @ts-nocheck\nexport default function ItemMovementPlugin(options = {}) {\n  const defaultOptions = {\n    moveable: true,\n    resizeable: true,\n    resizerContent: '',\n    collisionDetection: true,\n    outOfBorders: false,\n    snapStart: [],\n    snapEnd: [],\n    ghostNode: true\n  };\n  options = { ...defaultOptions, ...options };\n  options.snapStart = options.snapStart.slice();\n  options.snapEnd = options.snapEnd.slice();\n  const movementState = {};\n\n  /**\n   * Add moving functionality to items as action\n   *\n   * @param {Node} node DOM Node\n   * @param {Object} data\n   */\n  function action(node, data) {\n    const element = node.querySelector('.gantt-schedule-timeline-calendar__chart-gantt-items-row-item-content');\n    if (!options.moveable && !options.resizeable) {\n      return;\n    }\n    let moveable = options.moveable;\n    if (data.item.hasOwnProperty('moveable') && moveable) {\n      moveable = data.item.moveable;\n    }\n    if (data.row.hasOwnProperty('moveable') && moveable) {\n      moveable = data.row.moveable;\n    }\n    let resizeable = options.resizeable && (!data.item.hasOwnProperty('resizeable') || data.item.resizeable === true);\n    if (data.row.hasOwnProperty('resizeable') && resizeable) {\n      resizeable = data.row.resizeable;\n    }\n    const api = data.api;\n    let snapStart = options.snapStart;\n    if (typeof data.item.snapStart !== 'undefined' && Array.isArray(data.item.snapStart)) {\n      snapStart = item.snapStart;\n    }\n    let snapEnd = options.snapEnd;\n    if (typeof data.item.snapEnd !== 'undefined' && Array.isArray(data.item.snapEnd)) {\n      snapEnd = data.item.snapEnd;\n    }\n\n    if (resizeable) {\n      const resizerHTML = `<div class=\"${api.getClass('chart-gantt-items-row-item-content-resizer')}\">${\n        options.resizerContent\n      }</div>`;\n      // @ts-ignore\n      element.insertAdjacentHTML('beforeend', resizerHTML);\n    }\n\n    const el = element;\n    const resizerEl = el.querySelector('.gantt-schedule-timeline-calendar__chart-gantt-items-row-item-content-resizer');\n    const state = data.state;\n\n    if (typeof movementState[data.item.id] === 'undefined') {\n      movementState[data.item.id] = { moving: false, resizing: false };\n    }\n    const movement = movementState[data.item.id];\n\n    function createGhost(itemId, ev, ganttLeft, ganttTop) {\n      if (!options.ghostNode || typeof movementState[itemId].ghost !== 'undefined') {\n        return;\n      }\n      const ghost = element.cloneNode(true);\n      const style = getComputedStyle(element);\n      ghost.style.position = 'absolute';\n      ghost.style.left = ev.x - ganttLeft - movement.itemLeftCompensation + 'px';\n      const itemTop = ev.y - ganttTop - data.row.top - element.offsetTop;\n      movement.itemTop = itemTop;\n      ghost.style.top = ev.y - ganttTop - itemTop + 'px';\n      ghost.style.width = style.width;\n      ghost.style['box-shadow'] = '10px 10px 6px #00000020';\n      const height = element.clientHeight + 'px';\n      ghost.style.height = height;\n      ghost.style['line-height'] = height;\n      ghost.style.opacity = '0.75';\n      state.get('_internal.elements.gantt').appendChild(ghost);\n      movementState[itemId].ghost = ghost;\n      return ghost;\n    }\n\n    function moveGhost(ev) {\n      if (options.ghostNode) {\n        const left = ev.x - movement.ganttLeft - movement.itemLeftCompensation;\n        movement.ghost.style.left = left + 'px';\n        movement.ghost.style.top = ev.y - movement.ganttTop - movement.itemTop + 'px';\n      }\n    }\n\n    function destroyGhost(itemId) {\n      if (!options.ghostNode) {\n        return;\n      }\n      if (typeof movementState[itemId] !== 'undefined' && typeof movementState[itemId].ghost !== 'undefined') {\n        state.get('_internal.elements.gantt').removeChild(movementState[itemId].ghost);\n        delete movementState[itemId].ghost;\n      }\n      element.style.opacity = '1';\n    }\n\n    function labelMouseDown(ev) {\n      if (ev.button !== 0) {\n        return;\n      }\n      movement.moving = true;\n      const item = state.get(`config.chart.items.${data.item.id}`);\n      const chartLeftTime = state.get('_internal.chart.time.leftGlobal');\n      const timePerPixel = state.get('_internal.chart.time.timePerPixel');\n      const ganttRect = state.get('_internal.elements.gantt').getBoundingClientRect();\n      movement.ganttTop = ganttRect.top;\n      movement.ganttLeft = ganttRect.left;\n      movement.itemX = Math.round((item.time.start - chartLeftTime) / timePerPixel);\n      movement.itemLeftCompensation = ev.x - movement.ganttLeft - movement.itemX;\n      createGhost(data.item.id, ev, ganttRect.left, ganttRect.top);\n    }\n\n    function resizerMouseDown(ev) {\n      if (ev.button !== 0) {\n        return;\n      }\n      ev.stopPropagation();\n      movement.resizing = true;\n      const item = state.get(`config.chart.items.${data.item.id}`);\n      const chartLeftTime = state.get('_internal.chart.time.leftGlobal');\n      const timePerPixel = state.get('_internal.chart.time.timePerPixel');\n      const ganttRect = state.get('_internal.elements.gantt').getBoundingClientRect();\n      movement.ganttTop = ganttRect.top;\n      movement.ganttLeft = ganttRect.left;\n      movement.itemX = (item.time.end - chartLeftTime) / timePerPixel;\n      movement.itemLeftCompensation = ev.x - movement.ganttLeft - movement.itemX;\n    }\n\n    function isCollision(rowId, itemId, start, end) {\n      if (!options.collisionDetection) {\n        return false;\n      }\n      const time = state.get('_internal.chart.time');\n      if (options.outOfBorders && (start < time.from || end > time.to)) {\n        return true;\n      }\n      let diff = api.time.date(end).diff(start, 'milliseconds');\n      if (Math.sign(diff) === -1) {\n        diff = -diff;\n      }\n      if (diff <= 1) {\n        return true;\n      }\n      const row = state.get('config.list.rows.' + rowId);\n      for (const rowItem of row._internal.items) {\n        if (rowItem.id !== itemId) {\n          if (start >= rowItem.time.start && start <= rowItem.time.end) {\n            return true;\n          }\n          if (end >= rowItem.time.start && end <= rowItem.time.end) {\n            return true;\n          }\n          if (start <= rowItem.time.start && end >= rowItem.time.end) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    function snap(addMilliseconds, currentDate, addToEnd = 0, snapValues = []) {\n      let smallestDiff = Number.MAX_SAFE_INTEGER;\n      let smallestTime = 0;\n      for (let snapTime of snapValues) {\n        let diff = currentDate\n          .clone()\n          .add(addMilliseconds, 'milliseconds')\n          .diff(snapTime, 'milliseconds');\n        if (Math.sign(diff) === -1) {\n          diff = -diff;\n        }\n        if (diff < smallestDiff) {\n          smallestDiff = diff;\n          smallestTime = snapTime;\n        }\n      }\n      smallestTime += addToEnd;\n      return api.time.date(smallestTime);\n    }\n\n    function movementX(ev, row, item, zoom, timePerPixel) {\n      const left = ev.x - movement.ganttLeft - movement.itemLeftCompensation;\n      moveGhost(ev);\n      const leftMs = state.get('_internal.chart.time.leftGlobal') + left * timePerPixel;\n      const add = leftMs - item.time.start;\n      const originalStart = item.time.start;\n      const finalStartTime = snap(add, data.api.time.date(item.time.start), 0, snapStart);\n      const finalAdd = finalStartTime - originalStart;\n      const collision = isCollision(row.id, item.id, item.time.start + finalAdd, item.time.end + finalAdd);\n      if (finalAdd && !collision) {\n        state.update(`config.chart.items.${data.item.id}.time`, function moveItem(time) {\n          time.start += finalAdd;\n          time.end += finalAdd;\n          return time;\n        });\n      }\n    }\n\n    function resizeX(ev, row, item, zoom, timePerPixel) {\n      const time = state.get('_internal.chart.time');\n      const left = ev.x - movement.ganttLeft - movement.itemLeftCompensation;\n      const leftMs = time.leftGlobal + left * timePerPixel;\n      const add = leftMs - item.time.end;\n      if (item.time.end + add < item.time.start) {\n        return;\n      }\n      const originalEnd = item.time.end;\n      const finalEndTime = snap(add, data.api.time.date(item.time.end), -1, snapEnd);\n      const finalAdd = finalEndTime - originalEnd;\n      const collision = isCollision(row.id, item.id, item.time.start, item.time.end + finalAdd);\n      if (finalAdd && !collision) {\n        state.update(`config.chart.items.${data.item.id}.time.end`, function resizeItem(end) {\n          return (end += finalAdd);\n        });\n      }\n    }\n\n    function movementY(ev, row, item, zoom, timePerPixel) {\n      moveGhost(ev);\n      const top = ev.y - movement.ganttTop;\n      const visibleRows = state.get('_internal.list.visibleRows');\n      let index = 0;\n      for (const currentRow of visibleRows) {\n        if (currentRow.top > top) {\n          if (index > 0) {\n            return index - 1;\n          }\n          return 0;\n        }\n        index++;\n      }\n      return index;\n    }\n\n    function documentMouseMove(ev) {\n      let item, rowId, row, zoom, timePerPixel;\n      if (movement.moving || movement.resizing) {\n        item = state.get(`config.chart.items.${data.item.id}`);\n        rowId = state.get(`config.chart.items.${data.item.id}.rowId`);\n        row = state.get(`config.list.rows.${rowId}`);\n        zoom = state.get('config.chart.time.zoom');\n        timePerPixel = state.get('_internal.chart.time.timePerPixel');\n      }\n      if (movement.moving) {\n        if (moveable === true || moveable === 'x' || (Array.isArray(moveable) && moveable.includes(rowId))) {\n          movementX(ev, row, item, zoom, timePerPixel);\n        }\n        if (!moveable || moveable === 'x') {\n          return;\n        }\n        let visibleRowsIndex = movementY(ev, row, item, zoom, timePerPixel);\n        const visibleRows = state.get('_internal.list.visibleRows');\n        if (typeof visibleRows[visibleRowsIndex] === 'undefined') {\n          if (visibleRowsIndex > 0) {\n            visibleRowsIndex = visibleRows.length - 1;\n          } else if (visibleRowsIndex < 0) {\n            visibleRowsIndex = 0;\n          }\n        }\n        const newRow = visibleRows[visibleRowsIndex];\n        const newRowId = newRow.id;\n        const collision = isCollision(newRowId, item.id, item.time.start, item.time.end);\n        if (newRowId !== item.rowId && !collision) {\n          if (!Array.isArray(moveable) || moveable.includes(newRowId)) {\n            if (!newRow.hasOwnProperty('moveable') || newRow.moveable) {\n              state.update(`config.chart.items.${item.id}.rowId`, newRowId);\n            }\n          }\n        }\n      } else if (movement.resizing && (typeof item.resizeable === 'undefined' || item.resizeable === true)) {\n        resizeX(ev, row, item, zoom, timePerPixel);\n      }\n    }\n\n    function documentMouseUp(ev) {\n      movement.moving = false;\n      movement.resizing = false;\n      for (const itemId in movementState) {\n        movementState[itemId].moving = false;\n        movementState[itemId].resizing = false;\n        destroyGhost(itemId);\n      }\n    }\n    if (moveable) el.addEventListener('mousedown', labelMouseDown);\n    if (resizeable) resizerEl.addEventListener('mousedown', resizerMouseDown);\n    document.addEventListener('mousemove', documentMouseMove);\n    document.addEventListener('mouseup', documentMouseUp);\n\n    return {\n      destroy(node, data) {\n        if (moveable) el.removeEventListener('moudedown', labelMouseDown);\n        if (resizeable) resizerEl.removeEventListener('mousedown', resizerMouseDown);\n        document.removeEventListener('mousemove', documentMouseMove);\n        document.removeEventListener('mouseup', documentMouseUp);\n        if (resizeable) element.removeChild(resizerEl);\n      }\n    };\n  }\n\n  return function initializePlugin(state, api) {\n    state.update('config.actions.chart-gantt-items-row-item', actions => {\n      actions.push(action);\n      return actions;\n    });\n  };\n}\n"],"names":["options","moveable","resizeable","resizerContent","collisionDetection","outOfBorders","snapStart","snapEnd","ghostNode","slice","movementState","action","node","data","element","querySelector","item","hasOwnProperty","row","api","Array","isArray","resizerHTML","getClass","insertAdjacentHTML","el","resizerEl","state","id","moving","resizing","movement","moveGhost","ev","left","x","ganttLeft","itemLeftCompensation","ghost","style","top","y","ganttTop","itemTop","destroyGhost","itemId","get","removeChild","opacity","labelMouseDown","button","chartLeftTime","timePerPixel","ganttRect","getBoundingClientRect","itemX","Math","round","time","start","cloneNode","getComputedStyle","position","offsetTop","width","height","clientHeight","appendChild","createGhost","resizerMouseDown","stopPropagation","end","isCollision","rowId","from","to","diff","date","sign","rowItem","_internal","items","snap","addMilliseconds","currentDate","addToEnd","snapValues","smallestDiff","Number","MAX_SAFE_INTEGER","smallestTime","snapTime","clone","add","documentMouseMove","zoom","includes","originalStart","finalAdd","collision","update","movementX","visibleRowsIndex","visibleRows","index","currentRow","movementY","length","newRow","newRowId","leftGlobal","originalEnd","resizeX","documentMouseUp","addEventListener","document","[object Object]","removeEventListener","actions","push"],"mappings":"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"}