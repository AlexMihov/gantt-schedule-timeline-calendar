{"version":3,"file":"ItemMovement.plugin.js","sources":["../src/plugins/ItemMovement.plugin.js"],"sourcesContent":["// @ts-nocheck\nexport default function ItemMovementPlugin(options = {}) {\n  const defaultOptions = {\n    moveable: true,\n    resizeable: true,\n    resizerContent: '',\n    collisionDetection: true,\n    snapTo: []\n  };\n  options = { ...defaultOptions, ...options };\n  options.snapTo = options.snapTo.slice();\n  const movementState = {};\n\n  /**\n   * Add moving functionality to items as action\n   *\n   * @param {Node} node DOM Node\n   * @param {Object} data\n   */\n  function createAction(node, data) {\n    const element = node.querySelector('.gantt-shedule-timeline-calendar__chart-gantt-items-row-item-content');\n    if (!options.moveable && !options.resizeable) {\n      return;\n    }\n    let moveable = options.moveable;\n    if (data.item.hasOwnProperty('moveable') && moveable) {\n      moveable = data.item.moveable;\n    }\n    if (data.row.hasOwnProperty('moveable') && moveable) {\n      moveable = data.row.moveable;\n    }\n    let resizeable = options.resizeable && (!data.item.hasOwnProperty('resizeable') || data.item.resizeable === true);\n    if (data.row.hasOwnProperty('resizeable') && resizeable) {\n      resizeable = data.row.resizeable;\n    }\n    const api = data.api;\n\n    if (resizeable) {\n      const resizerHTML = `<div class=\"${api.getClass('chart-gantt-items-row-item-content-resizer')}\">${\n        options.resizerContent\n      }</div>`;\n      // @ts-ignore\n      element.insertAdjacentHTML('beforeend', resizerHTML);\n    }\n\n    const el = element;\n    const labelEl = el.querySelector('.gantt-shedule-timeline-calendar__chart-gantt-items-row-item-content-label');\n    const resizerEl = el.querySelector('.gantt-shedule-timeline-calendar__chart-gantt-items-row-item-content-resizer');\n\n    const state = data.state;\n\n    if (typeof movementState[data.item.id] === 'undefined') {\n      movementState[data.item.id] = { moving: false, resizing: false };\n    }\n    const movement = movementState[data.item.id];\n\n    function labelMouseDown(ev) {\n      movement.moving = true;\n      const item = state.get(`config.chart.items.${data.item.id}`);\n      const chartLeftTime = state.get('_internal.chart.time.leftGlobal');\n      const timePerPixel = state.get('_internal.chart.time.timePerPixel');\n      const ganttRect = state.get('_internal.elements.gantt').getBoundingClientRect();\n      movement.ganttTop = ganttRect.top;\n      movement.ganttLeft = ganttRect.left;\n      movement.itemX = Math.round((item.time.start - chartLeftTime) / timePerPixel);\n      movement.itemLeftCompensation = ev.x - movement.ganttLeft - movement.itemX;\n    }\n\n    function resizerMouseDown(ev) {\n      ev.stopPropagation();\n      movement.resizing = true;\n      const item = state.get(`config.chart.items.${data.item.id}`);\n      const chartLeftTime = state.get('_internal.chart.time.leftGlobal');\n      const timePerPixel = state.get('_internal.chart.time.timePerPixel');\n      const ganttRect = state.get('_internal.elements.gantt').getBoundingClientRect();\n      movement.ganttTop = ganttRect.top;\n      movement.ganttLeft = ganttRect.left;\n      movement.itemX = (item.time.end - chartLeftTime) / timePerPixel;\n      movement.itemLeftCompensation = ev.x - movement.ganttLeft - movement.itemX;\n    }\n\n    function isCollision(rowId, itemId, start, end) {\n      if (!options.collisionDetection) {\n        return false;\n      }\n      const time = state.get('_internal.chart.time');\n      if (start < time.from || end > time.to) {\n        return true;\n      }\n      if (api.time.date(end).diff(start, time.period) <= 0) {\n        return true;\n      }\n      const row = state.get('config.list.rows.' + rowId);\n      for (const rowItem of row._internal.items) {\n        if (rowItem.id !== itemId) {\n          if (start >= rowItem.time.start && start <= rowItem.time.end) {\n            return true;\n          }\n          if (end >= rowItem.time.start && end <= rowItem.time.end) {\n            return true;\n          }\n          if (start <= rowItem.time.start && end >= rowItem.time.end) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    function snap(addMilliseconds, currentDate, addToEnd = 0) {\n      let smallestDiff = Number.MAX_SAFE_INTEGER;\n      let smallestTime = 0;\n      for (let snapTime of options.snapTo) {\n        let diff = currentDate\n          .clone()\n          .add(addMilliseconds, 'milliseconds')\n          .diff(snapTime, 'milliseconds');\n        if (Math.sign(diff) === -1) {\n          diff = -diff;\n        }\n        if (diff < smallestDiff) {\n          smallestDiff = diff;\n          smallestTime = snapTime;\n        }\n      }\n      smallestTime += addToEnd;\n      return api.time.date(smallestTime);\n    }\n\n    function movementX(ev, row, item, zoom, timePerPixel) {\n      const left = ev.x - movement.ganttLeft - movement.itemLeftCompensation;\n      const leftMs = state.get('_internal.chart.time.leftGlobal') + left * timePerPixel;\n      const add = leftMs - item.time.start;\n      const originalStart = item.time.start;\n      const finalStartTime = snap(add, data.api.time.date(item.time.start));\n      const finalAdd = finalStartTime - originalStart;\n      const collision = isCollision(row.id, item.id, item.time.start + finalAdd, item.time.end + finalAdd);\n      if (finalAdd && !collision) {\n        state.update(`config.chart.items.${data.item.id}.time`, function moveItem(time) {\n          time.start += finalAdd;\n          time.end += finalAdd;\n          return time;\n        });\n      }\n    }\n\n    function resizeX(ev, row, item, zoom, timePerPixel) {\n      const time = state.get('_internal.chart.time');\n      const left = ev.x - movement.ganttLeft - movement.itemLeftCompensation;\n      const leftMs = time.leftGlobal + left * timePerPixel;\n      const add = leftMs - item.time.end;\n      if (item.time.end + add < item.time.start) {\n        return;\n      }\n      const originalEnd = item.time.end;\n      const finalEndTime = snap(add, data.api.time.date(item.time.end), -1);\n      const finalAdd = finalEndTime - originalEnd;\n      const collision = isCollision(row.id, item.id, item.time.start, item.time.end + finalAdd);\n      if (finalAdd && !collision) {\n        state.update(`config.chart.items.${data.item.id}.time.end`, function resizeItem(end) {\n          return (end += finalAdd);\n        });\n      }\n    }\n\n    function movementY(ev, row, item, zoom, timePerPixel) {\n      const top = ev.y - movement.ganttTop;\n      const visibleRows = state.get('_internal.list.visibleRows');\n      let index = 0;\n      for (const currentRow of visibleRows) {\n        if (currentRow.top > top) {\n          if (index > 0) {\n            return index - 1;\n          }\n          return 0;\n        }\n        index++;\n      }\n      return index;\n    }\n\n    function documentMouseMove(ev) {\n      let item, rowId, row, zoom, timePerPixel;\n      if (movement.moving || movement.resizing) {\n        item = state.get(`config.chart.items.${data.item.id}`);\n        rowId = state.get(`config.chart.items.${data.item.id}.rowId`);\n        row = state.get(`config.list.rows.${rowId}`);\n        zoom = state.get('config.chart.time.zoom');\n        timePerPixel = state.get('_internal.chart.time.timePerPixel');\n      }\n      if (movement.moving) {\n        if (moveable === true || moveable === 'x' || (Array.isArray(moveable) && moveable.includes(rowId))) {\n          movementX(ev, row, item, zoom, timePerPixel);\n        }\n        if (!moveable || moveable === 'x') {\n          return;\n        }\n        let visibleRowsIndex = movementY(ev, row, item, zoom, timePerPixel);\n        const visibleRows = state.get('_internal.list.visibleRows');\n        if (typeof visibleRows[visibleRowsIndex] === 'undefined') {\n          if (visibleRowsIndex > 0) {\n            visibleRowsIndex = visibleRows.length - 1;\n          } else if (visibleRowsIndex < 0) {\n            visibleRowsIndex = 0;\n          }\n        }\n        const newRow = visibleRows[visibleRowsIndex];\n        const newRowId = newRow.id;\n        const collision = isCollision(newRowId, item.id, item.time.start, item.time.end);\n        if (newRowId !== item.rowId && !collision) {\n          if (!Array.isArray(moveable) || moveable.includes(newRowId)) {\n            if (!newRow.hasOwnProperty('moveable') || newRow.moveable) {\n              state.update(`config.chart.items.${item.id}.rowId`, newRowId);\n            }\n          }\n        }\n      } else if (movement.resizing && (typeof item.resizeable === 'undefined' || item.resizeable === true)) {\n        resizeX(ev, row, item, zoom, timePerPixel);\n      }\n    }\n\n    function documentMouseUp(ev) {\n      movement.moving = false;\n      movement.resizing = false;\n    }\n\n    if (moveable) el.addEventListener('mousedown', labelMouseDown);\n    if (resizeable) resizerEl.addEventListener('mousedown', resizerMouseDown);\n    document.addEventListener('mousemove', documentMouseMove);\n    document.addEventListener('mouseup', documentMouseUp);\n\n    return {\n      update(data) {},\n      destroy() {\n        if (moveable) el.removeEventListener('moudedown', labelMouseDown);\n        if (resizeable) resizerEl.removeEventListener('mousedown', resizerMouseDown);\n        document.removeEventListener('mousemove', documentMouseMove);\n        document.removeEventListener('mouseup', documentMouseUp);\n      }\n    };\n  }\n\n  const action = {\n    create: createAction\n  };\n\n  return function initializePlugin(State, api) {\n    state.update('config.actions.chart-gantt-items-row-item', actions => {\n      if (!actions.some(a => a === action)) {\n        actions.push(action);\n      }\n      return actions;\n    });\n  };\n}\n"],"names":["options","moveable","resizeable","resizerContent","collisionDetection","snapTo","slice","movementState","action","create","node","data","element","querySelector","item","hasOwnProperty","row","api","resizerHTML","getClass","insertAdjacentHTML","el","resizerEl","state","id","moving","resizing","movement","labelMouseDown","ev","get","chartLeftTime","timePerPixel","ganttRect","getBoundingClientRect","ganttTop","top","ganttLeft","left","itemX","Math","round","time","start","itemLeftCompensation","x","resizerMouseDown","stopPropagation","end","isCollision","rowId","itemId","from","to","date","diff","period","rowItem","_internal","items","snap","addMilliseconds","currentDate","addToEnd","smallestDiff","Number","MAX_SAFE_INTEGER","smallestTime","snapTime","clone","add","sign","documentMouseMove","zoom","Array","isArray","includes","originalStart","finalAdd","collision","update","movementX","visibleRowsIndex","y","visibleRows","index","currentRow","movementY","length","newRow","newRowId","leftGlobal","originalEnd","resizeX","documentMouseUp","addEventListener","document","[object Object]","removeEventListener","State","actions","some","a","push"],"mappings":"0MACe,SAA4BA,EAAU,KAQnDA,EAAU,CANRC,UAAU,EACVC,YAAY,EACZC,eAAgB,GAChBC,oBAAoB,EACpBC,OAAQ,MAEwBL,IAC1BK,OAASL,EAAQK,OAAOC,QAChC,MAAMC,EAAgB,GAuOhBC,EAAS,CACbC,OAhOF,SAAsBC,EAAMC,GAC1B,MAAMC,EAAUF,EAAKG,cAAc,wEACnC,IAAKb,EAAQC,WAAaD,EAAQE,WAChC,OAEF,IAAID,EAAWD,EAAQC,SACnBU,EAAKG,KAAKC,eAAe,aAAed,IAC1CA,EAAWU,EAAKG,KAAKb,UAEnBU,EAAKK,IAAID,eAAe,aAAed,IACzCA,EAAWU,EAAKK,IAAIf,UAEtB,IAAIC,EAAaF,EAAQE,cAAgBS,EAAKG,KAAKC,eAAe,gBAA0C,IAAzBJ,EAAKG,KAAKZ,YACzFS,EAAKK,IAAID,eAAe,eAAiBb,IAC3CA,EAAaS,EAAKK,IAAId,YAExB,MAAMe,EAAMN,EAAKM,IAEjB,GAAIf,EAAY,CACd,MAAMgB,iBAA6BD,EAAIE,SAAS,kDAC9CnB,EAAQG,uBAGVS,EAAQQ,mBAAmB,YAAaF,GAG1C,MAAMG,EAAKT,EAELU,GADUD,EAAGR,cAAc,8EACfQ,EAAGR,cAAc,iFAE7BU,EAAQZ,EAAKY,WAEwB,IAAhChB,EAAcI,EAAKG,KAAKU,MACjCjB,EAAcI,EAAKG,KAAKU,IAAM,CAAEC,QAAQ,EAAOC,UAAU,IAE3D,MAAMC,EAAWpB,EAAcI,EAAKG,KAAKU,IAEzC,SAASI,EAAeC,GACtBF,EAASF,QAAS,EAClB,MAAMX,EAAOS,EAAMO,0BAA0BnB,EAAKG,KAAKU,MACjDO,EAAgBR,EAAMO,IAAI,mCAC1BE,EAAeT,EAAMO,IAAI,qCACzBG,EAAYV,EAAMO,IAAI,4BAA4BI,wBACxDP,EAASQ,SAAWF,EAAUG,IAC9BT,EAASU,UAAYJ,EAAUK,KAC/BX,EAASY,MAAQC,KAAKC,OAAO3B,EAAK4B,KAAKC,MAAQZ,GAAiBC,GAChEL,EAASiB,qBAAuBf,EAAGgB,EAAIlB,EAASU,UAAYV,EAASY,MAGvE,SAASO,EAAiBjB,GACxBA,EAAGkB,kBACHpB,EAASD,UAAW,EACpB,MAAMZ,EAAOS,EAAMO,0BAA0BnB,EAAKG,KAAKU,MACjDO,EAAgBR,EAAMO,IAAI,mCAC1BE,EAAeT,EAAMO,IAAI,qCACzBG,EAAYV,EAAMO,IAAI,4BAA4BI,wBACxDP,EAASQ,SAAWF,EAAUG,IAC9BT,EAASU,UAAYJ,EAAUK,KAC/BX,EAASY,OAASzB,EAAK4B,KAAKM,IAAMjB,GAAiBC,EACnDL,EAASiB,qBAAuBf,EAAGgB,EAAIlB,EAASU,UAAYV,EAASY,MAGvE,SAASU,EAAYC,EAAOC,EAAQR,EAAOK,GACzC,IAAKhD,EAAQI,mBACX,OAAO,EAET,MAAMsC,EAAOnB,EAAMO,IAAI,wBACvB,GAAIa,EAAQD,EAAKU,MAAQJ,EAAMN,EAAKW,GAClC,OAAO,EAET,GAAIpC,EAAIyB,KAAKY,KAAKN,GAAKO,KAAKZ,EAAOD,EAAKc,SAAW,EACjD,OAAO,EAET,MAAMxC,EAAMO,EAAMO,IAAI,oBAAsBoB,GAC5C,IAAK,MAAMO,KAAWzC,EAAI0C,UAAUC,MAClC,GAAIF,EAAQjC,KAAO2B,EAAQ,CACzB,GAAIR,GAASc,EAAQf,KAAKC,OAASA,GAASc,EAAQf,KAAKM,IACvD,OAAO,EAET,GAAIA,GAAOS,EAAQf,KAAKC,OAASK,GAAOS,EAAQf,KAAKM,IACnD,OAAO,EAET,GAAIL,GAASc,EAAQf,KAAKC,OAASK,GAAOS,EAAQf,KAAKM,IACrD,OAAO,EAIb,OAAO,EAGT,SAASY,EAAKC,EAAiBC,EAAaC,EAAW,GACrD,IAAIC,EAAeC,OAAOC,iBACtBC,EAAe,EACnB,IAAK,IAAIC,KAAYpE,EAAQK,OAAQ,CACnC,IAAIkD,EAAOO,EACRO,QACAC,IAAIT,EAAiB,gBACrBN,KAAKa,EAAU,iBACO,IAArB5B,KAAK+B,KAAKhB,KACZA,GAAQA,GAENA,EAAOS,IACTA,EAAeT,EACfY,EAAeC,GAInB,OADAD,GAAgBJ,EACT9C,EAAIyB,KAAKY,KAAKa,GAuDvB,SAASK,EAAkB3C,GACzB,IAAIf,EAAMoC,EAAOlC,EAAKyD,EAAMzC,EAQ5B,IAPIL,EAASF,QAAUE,EAASD,YAC9BZ,EAAOS,EAAMO,0BAA0BnB,EAAKG,KAAKU,MACjD0B,EAAQ3B,EAAMO,0BAA0BnB,EAAKG,KAAKU,YAClDR,EAAMO,EAAMO,wBAAwBoB,KACpCuB,EAAOlD,EAAMO,IAAI,0BACjBE,EAAeT,EAAMO,IAAI,sCAEvBH,EAASF,OAAQ,CAInB,KAHiB,IAAbxB,GAAkC,MAAbA,GAAqByE,MAAMC,QAAQ1E,IAAaA,EAAS2E,SAAS1B,KA9D/F,SAAmBrB,EAAIb,EAAKF,EAAM2D,EAAMzC,GACtC,MAAMM,EAAOT,EAAGgB,EAAIlB,EAASU,UAAYV,EAASiB,qBAE5C0B,EADS/C,EAAMO,IAAI,mCAAqCQ,EAAON,EAChDlB,EAAK4B,KAAKC,MACzBkC,EAAgB/D,EAAK4B,KAAKC,MAE1BmC,EADiBlB,EAAKU,EAAK3D,EAAKM,IAAIyB,KAAKY,KAAKxC,EAAK4B,KAAKC,QAC5BkC,EAC5BE,EAAY9B,EAAYjC,EAAIQ,GAAIV,EAAKU,GAAIV,EAAK4B,KAAKC,MAAQmC,EAAUhE,EAAK4B,KAAKM,IAAM8B,GACvFA,IAAaC,GACfxD,EAAMyD,6BAA6BrE,EAAKG,KAAKU,WAAW,SAAkBkB,GAGxE,OAFAA,EAAKC,OAASmC,EACdpC,EAAKM,KAAO8B,EACLpC,KAmDPuC,CAAUpD,EAAIb,EAAKF,EAAM2D,EAAMzC,IAE5B/B,GAAyB,MAAbA,EACf,OAEF,IAAIiF,EAhCR,SAAmBrD,EAAIb,EAAKF,EAAM2D,EAAMzC,GACtC,MAAMI,EAAMP,EAAGsD,EAAIxD,EAASQ,SACtBiD,EAAc7D,EAAMO,IAAI,8BAC9B,IAAIuD,EAAQ,EACZ,IAAK,MAAMC,KAAcF,EAAa,CACpC,GAAIE,EAAWlD,IAAMA,EACnB,OAAIiD,EAAQ,EACHA,EAAQ,EAEV,EAETA,IAEF,OAAOA,EAmBkBE,CAAU1D,GACjC,MAAMuD,EAAc7D,EAAMO,IAAI,mCACe,IAAlCsD,EAAYF,KACjBA,EAAmB,EACrBA,EAAmBE,EAAYI,OAAS,EAC/BN,EAAmB,IAC5BA,EAAmB,IAGvB,MAAMO,EAASL,EAAYF,GACrBQ,EAAWD,EAAOjE,GAClBuD,EAAY9B,EAAYyC,EAAU5E,EAAKU,GAAIV,EAAK4B,KAAKC,MAAO7B,EAAK4B,KAAKM,KACxE0C,IAAa5E,EAAKoC,OAAU6B,GACzBL,MAAMC,QAAQ1E,KAAaA,EAAS2E,SAASc,IAC3CD,EAAO1E,eAAe,cAAe0E,EAAOxF,UAC/CsB,EAAMyD,6BAA6BlE,EAAKU,WAAYkE,QAIjD/D,EAASD,eAAwC,IAApBZ,EAAKZ,aAAkD,IAApBY,EAAKZ,YAtElF,SAAiB2B,EAAIb,EAAKF,EAAM2D,EAAMzC,GACpC,MAAMU,EAAOnB,EAAMO,IAAI,wBACjBQ,EAAOT,EAAGgB,EAAIlB,EAASU,UAAYV,EAASiB,qBAE5C0B,EADS5B,EAAKiD,WAAarD,EAAON,EACnBlB,EAAK4B,KAAKM,IAC/B,GAAIlC,EAAK4B,KAAKM,IAAMsB,EAAMxD,EAAK4B,KAAKC,MAClC,OAEF,MAAMiD,EAAc9E,EAAK4B,KAAKM,IAExB8B,EADelB,EAAKU,EAAK3D,EAAKM,IAAIyB,KAAKY,KAAKxC,EAAK4B,KAAKM,MAAO,GACnC4C,EAC1Bb,EAAY9B,EAAYjC,EAAIQ,GAAIV,EAAKU,GAAIV,EAAK4B,KAAKC,MAAO7B,EAAK4B,KAAKM,IAAM8B,GAC5EA,IAAaC,GACfxD,EAAMyD,6BAA6BrE,EAAKG,KAAKU,eAAe,SAAoBwB,GAC9E,OAAQA,EAAO8B,KAyDjBe,CAAQhE,EAAIb,EAAKF,EAAM2D,EAAMzC,GAIjC,SAAS8D,EAAgBjE,GACvBF,EAASF,QAAS,EAClBE,EAASD,UAAW,EAQtB,OALIzB,GAAUoB,EAAG0E,iBAAiB,YAAanE,GAC3C1B,GAAYoB,EAAUyE,iBAAiB,YAAajD,GACxDkD,SAASD,iBAAiB,YAAavB,GACvCwB,SAASD,iBAAiB,UAAWD,GAE9B,CACLG,OAAOtF,KACPsF,UACMhG,GAAUoB,EAAG6E,oBAAoB,YAAatE,GAC9C1B,GAAYoB,EAAU4E,oBAAoB,YAAapD,GAC3DkD,SAASE,oBAAoB,YAAa1B,GAC1CwB,SAASE,oBAAoB,UAAWJ,OAS9C,OAAO,SAA0BK,EAAOlF,GACtCM,MAAMyD,OAAO,4CAA6CoB,IACnDA,EAAQC,KAAKC,GAAKA,IAAM9F,IAC3B4F,EAAQG,KAAK/F,GAER4F"}