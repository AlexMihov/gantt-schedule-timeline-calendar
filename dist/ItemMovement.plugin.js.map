{"version":3,"file":"ItemMovement.plugin.js","sources":["../src/plugins/ItemMovement.plugin.js"],"sourcesContent":["/**\n * ItemMovement plugin\n *\n * @copyright Rafal Pospiech <https://neuronet.io>\n * @author    Rafal Pospiech <neuronet.io@gmail.com>\n * @package   gantt-schedule-timeline-calendar\n * @license   GPL-3.0 (https://github.com/neuronetio/gantt-schedule-timeline-calendar/blob/master/LICENSE)\n * @link      https://github.com/neuronetio/gantt-schedule-timeline-calendar\n */\n\nexport default function ItemMovement(options = {}) {\n  const defaultOptions = {\n    moveable: true,\n    resizeable: true,\n    resizerContent: '',\n    collisionDetection: true,\n    outOfBorders: false,\n    snapStart: (timeStart, startDiff) => timeStart + startDiff,\n    snapEnd: (timeEnd, endDiff) => timeEnd + endDiff,\n    ghostNode: true\n  };\n  options = { ...defaultOptions, ...options };\n\n  const movementState = {};\n\n  /**\n   * Add moving functionality to items as action\n   *\n   * @param {Node} node DOM Node\n   * @param {Object} data\n   */\n  function action(node, data) {\n    // @ts-ignore\n    let element = node.querySelector('.gantt-schedule-timeline-calendar__chart-timeline-items-row-item-content');\n    if (!options.moveable && !options.resizeable) {\n      return;\n    }\n    let state;\n    let api;\n\n    function isMoveable(data) {\n      let moveable = options.moveable;\n      if (data.item.hasOwnProperty('moveable') && moveable) {\n        moveable = data.item.moveable;\n      }\n      if (data.row.hasOwnProperty('moveable') && moveable) {\n        moveable = data.row.moveable;\n      }\n      return moveable;\n    }\n\n    function isResizeable(data) {\n      let resizeable = options.resizeable && (!data.item.hasOwnProperty('resizeable') || data.item.resizeable === true);\n      if (data.row.hasOwnProperty('resizeable') && resizeable) {\n        resizeable = data.row.resizeable;\n      }\n      return resizeable;\n    }\n\n    function getMovement(data) {\n      const itemId = data.item.id;\n      if (typeof movementState[itemId] === 'undefined') {\n        movementState[itemId] = { moving: false, resizing: false };\n      }\n      return movementState[itemId];\n    }\n\n    function createGhost(data, ev, ganttLeft, ganttTop) {\n      const movement = getMovement(data);\n      if (!options.ghostNode || typeof movement.ghost !== 'undefined') {\n        return;\n      }\n      const ghost = element.cloneNode(true);\n      const style = getComputedStyle(element);\n      ghost.style.position = 'absolute';\n      ghost.style.left = ev.x - ganttLeft - movement.itemLeftCompensation + 'px';\n      const itemTop = ev.y - ganttTop - data.row.top - element.offsetTop;\n      movement.itemTop = itemTop;\n      ghost.style.top = ev.y - ganttTop - itemTop + 'px';\n      ghost.style.width = style.width;\n      ghost.style['box-shadow'] = '10px 10px 6px #00000020';\n      const height = element.clientHeight + 'px';\n      ghost.style.height = height;\n      ghost.style['line-height'] = height;\n      ghost.style.opacity = '0.75';\n      state.get('_internal.elements.gantt').appendChild(ghost);\n      movement.ghost = ghost;\n      return ghost;\n    }\n\n    function moveGhost(data, ev) {\n      if (options.ghostNode) {\n        const movement = getMovement(data);\n        const left = ev.x - movement.ganttLeft - movement.itemLeftCompensation;\n        const compensation = state.get('config.scroll.compensation');\n        movement.ghost.style.left = left + 'px';\n        movement.ghost.style.top = ev.y - movement.ganttTop - movement.itemTop + compensation + 'px';\n      }\n    }\n\n    function destroyGhost(itemId) {\n      if (!options.ghostNode) {\n        return;\n      }\n      if (typeof movementState[itemId] !== 'undefined' && typeof movementState[itemId].ghost !== 'undefined') {\n        state.get('_internal.elements.gantt').removeChild(movementState[itemId].ghost);\n        delete movementState[itemId].ghost;\n      }\n      element.style.opacity = '1';\n    }\n\n    function getSnapStart(data) {\n      let snapStart = options.snapStart;\n      if (typeof data.item.snapStart === 'function') {\n        snapStart = data.item.snapStart;\n      }\n      return snapStart;\n    }\n\n    function getSnapEnd(data) {\n      let snapEnd = options.snapEnd;\n      if (typeof data.item.snapEnd === 'function') {\n        snapEnd = data.item.snapEnd;\n      }\n      return snapEnd;\n    }\n\n    state = data.state;\n    api = data.api;\n\n    const resizerHTML = `<div class=\"${api.getClass('chart-timeline-items-row-item-content-resizer')}\">${\n      options.resizerContent\n    }</div>`;\n    // @ts-ignore\n    element.insertAdjacentHTML('beforeend', resizerHTML);\n    const resizerEl = element.querySelector(\n      '.gantt-schedule-timeline-calendar__chart-timeline-items-row-item-content-resizer'\n    );\n    if (!isResizeable(data)) {\n      resizerEl.style.visibility = 'hidden';\n    } else {\n      resizerEl.style.visibility = 'visible';\n    }\n\n    function labelMouseDown(ev) {\n      ev.stopPropagation();\n      if (ev.button !== 0) {\n        return;\n      }\n      // @ts-ignore\n      element = node.querySelector('.gantt-schedule-timeline-calendar__chart-timeline-items-row-item-content');\n      const movement = getMovement(data);\n      movement.moving = true;\n      const item = state.get(`config.chart.items.${data.item.id}`);\n      const chartLeftTime = state.get('_internal.chart.time.leftGlobal');\n      const timePerPixel = state.get('_internal.chart.time.timePerPixel');\n      const ganttRect = state.get('_internal.elements.gantt').getBoundingClientRect();\n      movement.ganttTop = ganttRect.top;\n      movement.ganttLeft = ganttRect.left;\n      movement.itemX = Math.round((item.time.start - chartLeftTime) / timePerPixel);\n      movement.itemLeftCompensation = ev.x - movement.ganttLeft - movement.itemX;\n      createGhost(data, ev, ganttRect.left, ganttRect.top);\n    }\n\n    function resizerMouseDown(ev) {\n      ev.stopPropagation();\n      if (ev.button !== 0) {\n        return;\n      }\n      const movement = getMovement(data);\n      movement.resizing = true;\n      const item = state.get(`config.chart.items.${data.item.id}`);\n      const chartLeftTime = state.get('_internal.chart.time.leftGlobal');\n      const timePerPixel = state.get('_internal.chart.time.timePerPixel');\n      const ganttRect = state.get('_internal.elements.gantt').getBoundingClientRect();\n      movement.ganttTop = ganttRect.top;\n      movement.ganttLeft = ganttRect.left;\n      movement.itemX = (item.time.end - chartLeftTime) / timePerPixel;\n      movement.itemLeftCompensation = ev.x - movement.ganttLeft - movement.itemX;\n    }\n\n    function isCollision(rowId, itemId, start, end) {\n      if (!options.collisionDetection) {\n        return false;\n      }\n      const time = state.get('_internal.chart.time');\n      if (options.outOfBorders && (start < time.from || end > time.to)) {\n        return true;\n      }\n      let diff = api.time.date(end).diff(start, 'milliseconds');\n      if (Math.sign(diff) === -1) {\n        diff = -diff;\n      }\n      if (diff <= 1) {\n        return true;\n      }\n      const row = state.get('config.list.rows.' + rowId);\n      for (const rowItem of row._internal.items) {\n        if (rowItem.id !== itemId) {\n          if (start >= rowItem.time.start && start <= rowItem.time.end) {\n            return true;\n          }\n          if (end >= rowItem.time.start && end <= rowItem.time.end) {\n            return true;\n          }\n          if (start <= rowItem.time.start && end >= rowItem.time.end) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    function movementX(ev, row, item, zoom, timePerPixel) {\n      ev.stopPropagation();\n      const movement = getMovement(data);\n      const left = ev.x - movement.ganttLeft - movement.itemLeftCompensation;\n      moveGhost(data, ev);\n      const leftMs = state.get('_internal.chart.time.leftGlobal') + left * timePerPixel;\n      const add = leftMs - item.time.start;\n      const originalStart = item.time.start;\n      const finalStartTime = getSnapStart(data)(item.time.start, add, item);\n      const finalAdd = finalStartTime - originalStart;\n      const collision = isCollision(row.id, item.id, item.time.start + finalAdd, item.time.end + finalAdd);\n      if (finalAdd && !collision) {\n        state.update(`config.chart.items.${data.item.id}.time`, function moveItem(time) {\n          time.start += finalAdd;\n          time.end = getSnapEnd(data)(time.end, finalAdd, item) - 1;\n          return time;\n        });\n      }\n    }\n\n    function resizeX(ev, row, item, zoom, timePerPixel) {\n      ev.stopPropagation();\n      if (!isResizeable(data)) {\n        return;\n      }\n      const time = state.get('_internal.chart.time');\n      const movement = getMovement(data);\n      const left = ev.x - movement.ganttLeft - movement.itemLeftCompensation;\n      const leftMs = time.leftGlobal + left * timePerPixel;\n      const add = leftMs - item.time.end;\n      if (item.time.end + add < item.time.start) {\n        return;\n      }\n      const originalEnd = item.time.end;\n      const finalEndTime = getSnapEnd(data)(item.time.end, add, item) - 1;\n      const finalAdd = finalEndTime - originalEnd;\n      const collision = isCollision(row.id, item.id, item.time.start, item.time.end + finalAdd);\n      if (finalAdd && !collision) {\n        state.update(`config.chart.items.${data.item.id}.time`, time => {\n          time.start = getSnapStart(data)(time.start, 0, item);\n          time.end = getSnapEnd(data)(time.end, finalAdd, item) - 1;\n          return time;\n        });\n      }\n    }\n\n    function movementY(ev, row, item, zoom, timePerPixel) {\n      ev.stopPropagation();\n      moveGhost(data, ev);\n      const movement = getMovement(data);\n      const top = ev.y - movement.ganttTop;\n      const visibleRows = state.get('_internal.list.visibleRows');\n      const compensation = state.get('config.scroll.compensation');\n      let index = 0;\n      for (const currentRow of visibleRows) {\n        if (currentRow.top + compensation > top) {\n          if (index > 0) {\n            return index - 1;\n          }\n          return 0;\n        }\n        index++;\n      }\n      return index;\n    }\n\n    function documentMouseMove(ev) {\n      const movement = getMovement(data);\n      let item, rowId, row, zoom, timePerPixel;\n      if (movement.moving || movement.resizing) {\n        ev.stopPropagation();\n        item = state.get(`config.chart.items.${data.item.id}`);\n        rowId = state.get(`config.chart.items.${data.item.id}.rowId`);\n        row = state.get(`config.list.rows.${rowId}`);\n        zoom = state.get('config.chart.time.zoom');\n        timePerPixel = state.get('_internal.chart.time.timePerPixel');\n      }\n      const moveable = isMoveable(data);\n      if (movement.moving) {\n        if (moveable === true || moveable === 'x' || (Array.isArray(moveable) && moveable.includes(rowId))) {\n          movementX(ev, row, item, zoom, timePerPixel);\n        }\n        if (!moveable || moveable === 'x') {\n          return;\n        }\n        let visibleRowsIndex = movementY(ev, row, item, zoom, timePerPixel);\n        const visibleRows = state.get('_internal.list.visibleRows');\n        if (typeof visibleRows[visibleRowsIndex] === 'undefined') {\n          if (visibleRowsIndex > 0) {\n            visibleRowsIndex = visibleRows.length - 1;\n          } else if (visibleRowsIndex < 0) {\n            visibleRowsIndex = 0;\n          }\n        }\n        const newRow = visibleRows[visibleRowsIndex];\n        const newRowId = newRow.id;\n        const collision = isCollision(newRowId, item.id, item.time.start, item.time.end);\n        if (newRowId !== item.rowId && !collision) {\n          if (!Array.isArray(moveable) || moveable.includes(newRowId)) {\n            if (!newRow.hasOwnProperty('moveable') || newRow.moveable) {\n              state.update(`config.chart.items.${item.id}.rowId`, newRowId);\n            }\n          }\n        }\n      } else if (movement.resizing && (typeof item.resizeable === 'undefined' || item.resizeable === true)) {\n        resizeX(ev, row, item, zoom, timePerPixel);\n      }\n    }\n\n    function documentMouseUp(ev) {\n      const movement = getMovement(data);\n      if (movement.moving || movement.resizing) {\n        ev.stopPropagation();\n      }\n      movement.moving = false;\n      movement.resizing = false;\n      for (const itemId in movementState) {\n        movementState[itemId].moving = false;\n        movementState[itemId].resizing = false;\n        destroyGhost(itemId);\n      }\n    }\n    element.addEventListener('mousedown', labelMouseDown);\n    resizerEl.addEventListener('mousedown', resizerMouseDown, { capture: true });\n    document.addEventListener('mousemove', documentMouseMove, { capture: true, passive: true });\n    document.addEventListener('mouseup', documentMouseUp, { capture: true, passive: true });\n    return {\n      update(node, changedData) {\n        data = changedData;\n        if (!isResizeable(data)) {\n          resizerEl.style.visibility = 'hidden';\n        } else {\n          resizerEl.style.visibility = 'visible';\n        }\n      },\n      destroy(node, data) {\n        element.removeEventListener('mousedown', labelMouseDown);\n        resizerEl.removeEventListener('mousedown', resizerMouseDown);\n        document.removeEventListener('mousemove', documentMouseMove);\n        document.removeEventListener('mouseup', documentMouseUp);\n        resizerEl.remove();\n      }\n    };\n  }\n\n  return function initialize(state, api) {\n    state.update('config.actions.chart-timeline-items-row-item', actions => {\n      actions.push(action);\n      return actions;\n    });\n  };\n}\n"],"names":["options","moveable","resizeable","resizerContent","collisionDetection","outOfBorders","snapStart","timeStart","startDiff","snapEnd","timeEnd","endDiff","ghostNode","movementState","action","node","data","state","api","element","querySelector","isResizeable","item","hasOwnProperty","row","getMovement","itemId","id","moving","resizing","moveGhost","ev","movement","left","x","ganttLeft","itemLeftCompensation","compensation","get","ghost","style","top","y","ganttTop","itemTop","destroyGhost","removeChild","opacity","getSnapStart","getSnapEnd","resizerHTML","getClass","insertAdjacentHTML","resizerEl","labelMouseDown","stopPropagation","button","chartLeftTime","timePerPixel","ganttRect","getBoundingClientRect","itemX","Math","round","time","start","cloneNode","getComputedStyle","position","offsetTop","width","height","clientHeight","appendChild","createGhost","resizerMouseDown","end","isCollision","rowId","from","to","diff","date","sign","rowItem","_internal","items","documentMouseMove","zoom","isMoveable","Array","isArray","includes","add","originalStart","finalAdd","collision","update","movementX","visibleRowsIndex","visibleRows","index","currentRow","movementY","length","newRow","newRowId","leftGlobal","originalEnd","resizeX","documentMouseUp","visibility","addEventListener","capture","document","passive","[object Object]","changedData","removeEventListener","remove","actions","push"],"mappings":"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"}