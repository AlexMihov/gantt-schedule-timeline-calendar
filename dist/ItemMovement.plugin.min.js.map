{"version":3,"file":"ItemMovement.plugin.min.js","sources":["../src/plugins/ItemMovement.plugin.ts"],"sourcesContent":["/**\n * ItemMovement plugin\n *\n * @copyright Rafal Pospiech <https://neuronet.io>\n * @author    Rafal Pospiech <neuronet.io@gmail.com>\n * @package   gantt-schedule-timeline-calendar\n * @license   GPL-3.0 (https://github.com/neuronetio/gantt-schedule-timeline-calendar/blob/master/LICENSE)\n * @link      https://github.com/neuronetio/gantt-schedule-timeline-calendar\n */\n\nexport interface Options {\n  moveable?: boolean | string;\n  resizeable?: boolean | string;\n  resizerContent?: string;\n  collisionDetection?: boolean;\n  outOfBorders?: boolean;\n  snapStart?: (timeStart: number, startDiff: number, item: object) => number;\n  snapEnd?: (timeEnd: number, endDiff: number, item: object) => number;\n  ghostNode?: boolean;\n  wait?: number;\n}\n\nconst pointerEventsExists = typeof PointerEvent !== 'undefined';\n\nexport default function ItemMovement(options: Options = {}) {\n  const defaultOptions = {\n    moveable: true,\n    resizeable: true,\n    resizerContent: '',\n    collisionDetection: true,\n    outOfBorders: false,\n    snapStart(timeStart, startDiff) {\n      return timeStart + startDiff;\n    },\n    snapEnd(timeEnd, endDiff) {\n      return timeEnd + endDiff;\n    },\n    ghostNode: true,\n    wait: 0\n  };\n  options = { ...defaultOptions, ...options };\n\n  const movementState = {};\n\n  /**\n   * Add moving functionality to items as action\n   *\n   * @param {HTMLElement} element DOM Node\n   * @param {Object} data\n   */\n  function action(element: HTMLElement, data) {\n    if (!options.moveable && !options.resizeable) {\n      return;\n    }\n    const state = data.state;\n    const api = data.api;\n\n    function isMoveable(data) {\n      let moveable = options.moveable;\n      if (data.item.hasOwnProperty('moveable') && moveable) {\n        moveable = data.item.moveable;\n      }\n      if (data.row.hasOwnProperty('moveable') && moveable) {\n        moveable = data.row.moveable;\n      }\n      return moveable;\n    }\n\n    function isResizeable(data) {\n      let resizeable = options.resizeable && (!data.item.hasOwnProperty('resizeable') || data.item.resizeable === true);\n      if (data.row.hasOwnProperty('resizeable') && resizeable) {\n        resizeable = data.row.resizeable;\n      }\n      return resizeable;\n    }\n\n    function getMovement(data) {\n      const itemId = data.item.id;\n      if (typeof movementState[itemId] === 'undefined') {\n        movementState[itemId] = { moving: false, resizing: false, waiting: false };\n      }\n      return movementState[itemId];\n    }\n\n    function saveMovement(itemId, movement) {\n      state.update(`config.plugin.ItemMovement.items.${itemId}`, movement);\n      state.update('config.plugin.ItemMovement.movement', current => {\n        if (!current) {\n          current = { moving: false, waiting: false };\n        }\n        current.moving = movement.moving;\n        current.waiting = movement.waiting;\n        return current;\n      });\n    }\n\n    function createGhost(data, normalized, ganttLeft, ganttTop) {\n      const movement = getMovement(data);\n      if (!options.ghostNode || typeof movement.ghost !== 'undefined') {\n        return;\n      }\n      const ghost = element.cloneNode(true) as HTMLElement;\n      const style = getComputedStyle(element);\n      const compensationY = state.get('config.scroll.compensation.y');\n      ghost.style.position = 'absolute';\n      ghost.style.left = normalized.clientX - ganttLeft - movement.itemLeftCompensation + 'px';\n      const itemTop = normalized.clientY - ganttTop - element.offsetTop - compensationY + parseInt(style['margin-top']);\n      movement.itemTop = itemTop;\n      ghost.style.top = normalized.clientY - ganttTop - itemTop + 'px';\n      ghost.style.width = style.width;\n      ghost.style['box-shadow'] = '10px 10px 6px #00000020';\n      const height = element.clientHeight + 'px';\n      ghost.style.height = height;\n      ghost.style['line-height'] = element.clientHeight - 18 + 'px';\n      ghost.style.opacity = '0.6';\n      ghost.style.transform = 'scale(1.05, 1.05)';\n      state.get('_internal.elements.chart-timeline').appendChild(ghost);\n      movement.ghost = ghost;\n      saveMovement(data.item.id, movement);\n      return ghost;\n    }\n\n    function moveGhost(data, normalized) {\n      if (options.ghostNode) {\n        const movement = getMovement(data);\n        const left = normalized.clientX - movement.ganttLeft - movement.itemLeftCompensation;\n        movement.ghost.style.left = left + 'px';\n        movement.ghost.style.top =\n          normalized.clientY -\n          movement.ganttTop -\n          movement.itemTop +\n          parseInt(getComputedStyle(element)['margin-top']) +\n          'px';\n        saveMovement(data.item.id, movement);\n      }\n    }\n\n    function destroyGhost(itemId) {\n      if (!options.ghostNode) {\n        return;\n      }\n      if (typeof movementState[itemId] !== 'undefined' && typeof movementState[itemId].ghost !== 'undefined') {\n        state.get('_internal.elements.chart-timeline').removeChild(movementState[itemId].ghost);\n        delete movementState[itemId].ghost;\n        saveMovement(data.item.id, movementState[itemId]);\n      }\n    }\n\n    function getSnapStart(data) {\n      let snapStart = options.snapStart;\n      if (typeof data.item.snapStart === 'function') {\n        snapStart = data.item.snapStart;\n      }\n      return snapStart;\n    }\n\n    function getSnapEnd(data) {\n      let snapEnd = options.snapEnd;\n      if (typeof data.item.snapEnd === 'function') {\n        snapEnd = data.item.snapEnd;\n      }\n      return snapEnd;\n    }\n\n    const resizerHTML = `<div class=\"${api.getClass('chart-timeline-items-row-item-resizer')}\">${\n      options.resizerContent\n    }</div>`;\n    // @ts-ignore\n    element.insertAdjacentHTML('beforeend', resizerHTML);\n    const resizerEl: HTMLElement = element.querySelector(\n      '.gantt-schedule-timeline-calendar__chart-timeline-items-row-item-resizer'\n    );\n    if (!isResizeable(data)) {\n      resizerEl.style.visibility = 'hidden';\n    } else {\n      resizerEl.style.visibility = 'visible';\n    }\n\n    function labelDown(ev) {\n      const normalized = api.normalizePointerEvent(ev);\n      if ((ev.type === 'pointerdown' || ev.type === 'mousedown') && ev.button !== 0) {\n        return;\n      }\n      const movement = getMovement(data);\n      movement.waiting = true;\n      saveMovement(data.item.id, movement);\n      setTimeout(() => {\n        ev.stopPropagation();\n        ev.preventDefault();\n        if (!movement.waiting) return;\n        movement.moving = true;\n        const item = state.get(`config.chart.items.${data.item.id}`);\n        const chartLeftTime = state.get('_internal.chart.time.leftGlobal');\n        const timePerPixel = state.get('_internal.chart.time.timePerPixel');\n        const ganttRect = state.get('_internal.elements.chart-timeline').getBoundingClientRect();\n        movement.ganttTop = ganttRect.top;\n        movement.ganttLeft = ganttRect.left;\n        movement.itemX = Math.round((item.time.start - chartLeftTime) / timePerPixel);\n        movement.itemLeftCompensation = normalized.clientX - movement.ganttLeft - movement.itemX;\n        saveMovement(data.item.id, movement);\n        createGhost(data, normalized, ganttRect.left, ganttRect.top);\n      }, options.wait);\n    }\n\n    function resizerDown(ev) {\n      ev.stopPropagation();\n      ev.preventDefault();\n      if ((ev.type === 'pointerdown' || ev.type === 'mousedown') && ev.button !== 0) {\n        return;\n      }\n      const normalized = api.normalizePointerEvent(ev);\n      const movement = getMovement(data);\n      movement.resizing = true;\n      const item = state.get(`config.chart.items.${data.item.id}`);\n      const chartLeftTime = state.get('_internal.chart.time.leftGlobal');\n      const timePerPixel = state.get('_internal.chart.time.timePerPixel');\n      const ganttRect = state.get('_internal.elements.chart-timeline').getBoundingClientRect();\n      movement.ganttTop = ganttRect.top;\n      movement.ganttLeft = ganttRect.left;\n      movement.itemX = (item.time.end - chartLeftTime) / timePerPixel;\n      movement.itemLeftCompensation = normalized.clientX - movement.ganttLeft - movement.itemX;\n      saveMovement(data.item.id, movement);\n    }\n\n    function isCollision(rowId, itemId, start, end) {\n      if (!options.collisionDetection) {\n        return false;\n      }\n      const time = state.get('_internal.chart.time');\n      if (options.outOfBorders && (start < time.from || end > time.to)) {\n        return true;\n      }\n      let diff = api.time.date(end).diff(start, 'milliseconds');\n      if (Math.sign(diff) === -1) {\n        diff = -diff;\n      }\n      if (diff <= 1) {\n        return true;\n      }\n      const row = state.get('config.list.rows.' + rowId);\n      for (const rowItem of row._internal.items) {\n        if (rowItem.id !== itemId) {\n          if (start >= rowItem.time.start && start <= rowItem.time.end) {\n            return true;\n          }\n          if (end >= rowItem.time.start && end <= rowItem.time.end) {\n            return true;\n          }\n          if (start <= rowItem.time.start && end >= rowItem.time.end) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    function movementX(normalized, row, item, zoom, timePerPixel) {\n      const movement = getMovement(data);\n      const left = normalized.clientX - movement.ganttLeft - movement.itemLeftCompensation;\n      moveGhost(data, normalized);\n      const leftMs = state.get('_internal.chart.time.leftGlobal') + left * timePerPixel;\n      const add = leftMs - item.time.start;\n      const originalStart = item.time.start;\n      const finalStartTime = getSnapStart(data)(item.time.start, add, item);\n      const finalAdd = finalStartTime - originalStart;\n      const collision = isCollision(row.id, item.id, item.time.start + finalAdd, item.time.end + finalAdd);\n      if (finalAdd && !collision) {\n        state.update(`config.chart.items.${data.item.id}.time`, function moveItem(time) {\n          time.start += finalAdd;\n          time.end = getSnapEnd(data)(time.end, finalAdd, item) - 1;\n          return time;\n        });\n      }\n    }\n\n    function resizeX(normalized, row, item, zoom, timePerPixel) {\n      if (!isResizeable(data)) {\n        return;\n      }\n      const time = state.get('_internal.chart.time');\n      const movement = getMovement(data);\n      const left = normalized.clientX - movement.ganttLeft - movement.itemLeftCompensation;\n      const leftMs = time.leftGlobal + left * timePerPixel;\n      const add = leftMs - item.time.end;\n      if (item.time.end + add < item.time.start) {\n        return;\n      }\n      const originalEnd = item.time.end;\n      const finalEndTime = getSnapEnd(data)(item.time.end, add, item) - 1;\n      const finalAdd = finalEndTime - originalEnd;\n      const collision = isCollision(row.id, item.id, item.time.start, item.time.end + finalAdd);\n      if (finalAdd && !collision) {\n        state.update(`config.chart.items.${data.item.id}.time`, time => {\n          time.start = getSnapStart(data)(time.start, 0, item);\n          time.end = getSnapEnd(data)(time.end, finalAdd, item) - 1;\n          return time;\n        });\n      }\n    }\n\n    function movementY(normalized, row, item, zoom, timePerPixel) {\n      moveGhost(data, normalized);\n      const movement = getMovement(data);\n      const top = normalized.clientY - movement.ganttTop;\n      const visibleRows = state.get('_internal.list.visibleRows');\n      const compensationY = state.get('config.scroll.compensation.y');\n      let index = 0;\n      for (const currentRow of visibleRows) {\n        if (currentRow.top + compensationY > top) {\n          if (index > 0) {\n            return index - 1;\n          }\n          return 0;\n        }\n        index++;\n      }\n      return index;\n    }\n\n    function documentMove(ev) {\n      const movement = getMovement(data);\n      const normalized = api.normalizePointerEvent(ev);\n      let item, rowId, row, zoom, timePerPixel;\n      if (movement.moving || movement.resizing) {\n        ev.stopPropagation();\n        ev.preventDefault();\n        item = state.get(`config.chart.items.${data.item.id}`);\n        rowId = state.get(`config.chart.items.${data.item.id}.rowId`);\n        row = state.get(`config.list.rows.${rowId}`);\n        zoom = state.get('config.chart.time.zoom');\n        timePerPixel = state.get('_internal.chart.time.timePerPixel');\n      }\n      const moveable = isMoveable(data);\n      if (movement.moving) {\n        if (moveable === true || moveable === 'x' || (Array.isArray(moveable) && moveable.includes(rowId))) {\n          movementX(normalized, row, item, zoom, timePerPixel);\n        }\n        if (!moveable || moveable === 'x') {\n          return;\n        }\n        let visibleRowsIndex = movementY(normalized, row, item, zoom, timePerPixel);\n        const visibleRows = state.get('_internal.list.visibleRows');\n        if (typeof visibleRows[visibleRowsIndex] === 'undefined') {\n          if (visibleRowsIndex > 0) {\n            visibleRowsIndex = visibleRows.length - 1;\n          } else if (visibleRowsIndex < 0) {\n            visibleRowsIndex = 0;\n          }\n        }\n        const newRow = visibleRows[visibleRowsIndex];\n        const newRowId = newRow.id;\n        const collision = isCollision(newRowId, item.id, item.time.start, item.time.end);\n        if (newRowId !== item.rowId && !collision) {\n          if (!Array.isArray(moveable) || moveable.includes(newRowId)) {\n            if (!newRow.hasOwnProperty('moveable') || newRow.moveable) {\n              state.update(`config.chart.items.${item.id}.rowId`, newRowId);\n            }\n          }\n        }\n      } else if (movement.resizing && (typeof item.resizeable === 'undefined' || item.resizeable === true)) {\n        resizeX(normalized, row, item, zoom, timePerPixel);\n      }\n    }\n\n    function documentUp(ev) {\n      const movement = getMovement(data);\n      if (movement.moving || movement.resizing) {\n        ev.stopPropagation();\n        ev.preventDefault();\n      }\n      movement.moving = false;\n      movement.waiting = false;\n      movement.resizing = false;\n      saveMovement(data, movement);\n      for (const itemId in movementState) {\n        movementState[itemId].moving = false;\n        movementState[itemId].resizing = false;\n        movementState[itemId].waiting = false;\n        destroyGhost(itemId);\n      }\n    }\n\n    if (pointerEventsExists) {\n      element.addEventListener('pointerdown', labelDown);\n      resizerEl.addEventListener('pointerdown', resizerDown);\n      document.addEventListener('pointermove', documentMove);\n      document.addEventListener('pointerup', documentUp);\n    } else {\n      element.addEventListener('touchstart', labelDown);\n      resizerEl.addEventListener('touchstart', resizerDown);\n      document.addEventListener('touchmove', documentMove);\n      document.addEventListener('touchend', documentUp);\n      document.addEventListener('touchcancel', documentUp);\n      element.addEventListener('mousedown', labelDown);\n      resizerEl.addEventListener('mousedown', resizerDown);\n      document.addEventListener('mousemove', documentMove);\n      document.addEventListener('mouseup', documentUp);\n    }\n\n    return {\n      update(node, changedData) {\n        console.log('updated');\n        if (!isResizeable(changedData) && resizerEl.style.visibility === 'visible') {\n          resizerEl.style.visibility = 'hidden';\n        } else if (isResizeable(changedData) && resizerEl.style.visibility === 'hidden') {\n          resizerEl.style.visibility = 'visible';\n        }\n        data = changedData;\n      },\n      destroy(node, data) {\n        if (pointerEventsExists) {\n          element.removeEventListener('pointerdown', labelDown);\n          resizerEl.removeEventListener('pointerdown', resizerDown);\n          document.removeEventListener('pointermove', documentMove);\n          document.removeEventListener('pointerup', documentUp);\n        } else {\n          element.removeEventListener('mousedown', labelDown);\n          resizerEl.removeEventListener('mousedown', resizerDown);\n          document.removeEventListener('mousemove', documentMove);\n          document.removeEventListener('mouseup', documentUp);\n          element.removeEventListener('touchstart', labelDown);\n          resizerEl.removeEventListener('touchstart', resizerDown);\n          document.removeEventListener('touchmove', documentMove);\n          document.removeEventListener('touchend', documentUp);\n          document.removeEventListener('touchcancel', documentUp);\n        }\n        resizerEl.remove();\n      }\n    };\n  }\n\n  return function initialize(vido) {\n    vido.state.update('config.actions.chart-timeline-items-row-item', actions => {\n      actions.push(action);\n      return actions;\n    });\n  };\n}\n"],"names":["pointerEventsExists","PointerEvent","ItemMovement","options","defaultOptions","moveable","resizeable","resizerContent","collisionDetection","outOfBorders","snapStart","timeStart","startDiff","snapEnd","timeEnd","endDiff","ghostNode","wait","movementState","action","element","data","state","api","isResizeable","item","hasOwnProperty","row","getMovement","itemId","id","moving","resizing","waiting","saveMovement","movement","update","current","moveGhost","normalized","left","clientX","ganttLeft","itemLeftCompensation","ghost","style","top","clientY","ganttTop","itemTop","parseInt","getComputedStyle","destroyGhost","get","removeChild","getSnapStart","getSnapEnd","resizerHTML","getClass","insertAdjacentHTML","resizerEl","querySelector","labelDown","ev","normalizePointerEvent","type","button","setTimeout","stopPropagation","preventDefault","chartLeftTime","timePerPixel","ganttRect","getBoundingClientRect","itemX","Math","round","time","start","createGhost","cloneNode","compensationY","position","offsetTop","width","height","clientHeight","opacity","transform","appendChild","resizerDown","end","isCollision","rowId","from","to","diff","date","sign","rowItem","_internal","items","documentMove","zoom","isMoveable","Array","isArray","includes","movementX","add","originalStart","finalAdd","collision","moveItem","visibleRowsIndex","movementY","visibleRows","index","currentRow","length","newRow","newRowId","resizeX","leftGlobal","originalEnd","documentUp","visibility","addEventListener","document","[object Object]","node","changedData","console","log","removeEventListener","remove","initialize","vido","actions","push"],"mappings":"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"}