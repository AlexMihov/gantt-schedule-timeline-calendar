!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self).DependencyLines=t()}(this,(function(){"use strict";
/**
   * DependencyLines plugin
   *
   * @copyright Rafal Pospiech <https://neuronet.io>
   * @author    Rafal Pospiech <neuronet.io@gmail.com>
   * @package   gantt-schedule-timeline-calendar
   * @license   GPL-3.0 (https://github.com/neuronetio/gantt-schedule-timeline-calendar/blob/master/LICENSE)
   * @link      https://github.com/neuronetio/gantt-schedule-timeline-calendar
   */let e,t,n;const s=document.createElement("div");s.style.position="absolute",s.style.left="0",s.style.top="0",s.style.width="var(--width)",s.style.height="var(--height)";const o={type:"quadratic",handle:{style:{},width:40,height:40},connector:{style:{},width:40,height:40}};function DependencyLinesLines(e){const{html:t,onDestroy:n,api:s,state:o,reuseComponents:i}=e;let c;n(o.subscribe("config.classNames",()=>{c=s.getClass("chart-timeline-dependency-lines-lines")}));let l=[];return n(o.subscribe("_internal.chart.visibleItems",e=>{const t=o.get("config.list.rows"),n={};for(const s in e){const o=e[s];"string"==typeof o.rowId&&t[o.rowId]&&(n[o.rowId]=t[o.rowId])}})),e=>t`
      <div class="${c}">${l.map(e=>e.html())}</div>
    `}let i=!1;function ItemDependencyLineHandle(t,n){const{html:s,onDestroy:o,api:c,state:l,StyleMap:a,onChange:r,Detach:d,update:p,Actions:h,PointerAction:m}=t,y="chart-timeline-dependency-lines-handle",f=Object.assign({},n);let u,g;o(l.subscribe("config.classNames",()=>{u=c.getClass(y),g=c.getClass("chart-timeline-dependency-lines-handle--connector")}));let w=!1;const b=new d(()=>w),v=new d(()=>w||!i||i===n.item.id),x=new a({left:"0px",top:"0px",width:e.handle.width+"px",height:e.handle.height+"px"}),D=new a({left:"0px",top:"0px",width:e.connector.width+"px",height:e.connector.height+"px"});function updatePosition(){x.style.left=c.time.globalTimeToViewPixelOffset(n.item.time.end,!0)+"px",x.style.top=n.row.top+"px",D.style.left=c.time.globalTimeToViewPixelOffset(n.item.time.start,!0)-e.connector.width-1+"px",D.style.top=n.row.top+"px";for(const t in e.handle.style)x.style[t]=e.handle.style[t];for(const t in e.connector.style)D.style[t]=e.connector.style[t]}r((function change(e,t){if(t.leave)return w=!0,p();w=!1,n=e;for(const e in n)f[e]=n[e];updatePosition(),p()})),o(l.subscribeAll(["_internal.chart.time","config.scroll.compensation"],()=>{updatePosition(),p()}));const $=c.getActions(y);f.pointerOptions={axis:"xy",onDown({event:e}){e.stopPropagation(),e.preventDefault(),i=n.item.id,p()},onMove({event:e,movementX:t,movementY:n}){i&&(e.stopPropagation(),e.preventDefault(),console.log("move?",{movementX:t,movementY:n}),p())},onUp({event:e}){i&&(e.stopPropagation(),e.preventDefault(),i=!1,p())}},$.push(m);const O=h.create($,f);return e=>s`
      <div detach=${b} class=${u} style=${x} data-actions=${O}></div>
      <div detach=${v} class=${g} style=${D}></div>
    `}function DependencyLinesHandles(e){const{html:t,onDestroy:n,api:s,state:o,reuseComponents:i}=e;let c;n(o.subscribe("config.classNames",()=>{c=s.getClass("chart-timeline-dependency-lines-handles")}));const l=[];return n(o.subscribe("_internal.chart.visibleItems",e=>{const t=[],n=o.get("config.list.rows");for(const s of e){const e=n[s.rowId];e&&t.push({item:s,row:e})}return i(l,t,e=>e,ItemDependencyLineHandle)})),e=>t`
      <div class="${c}">${l.map(e=>e.html())}</div>
    `}return function DependencyLinesPlugin(s=o){return function initialize(i){t=i.state,n=i.api,o.connector.width=o.connector.height=t.get("config.list.rowHeight")||40,e=Object.assign(Object.assign({},o),s),e.connector=Object.assign(Object.assign({},o.connector),e.connector),e.connector.style=Object.assign(Object.assign({},o.connector.style),e.connector.style),e.handle=Object.assign(Object.assign({},o.handle),e.handle),e.handle.style=Object.assign(Object.assign({},o.handle.style),e.handle.style);const c=i.createComponent(DependencyLinesLines);t.update("config.wrappers.ChartTimelineGrid",e=>(function DependencyLinesGridWrapper(t,n){const s=i.html`${t}${c.html()}`;return e(s,n)}));const l=i.createComponent(DependencyLinesHandles);return t.update("config.wrappers.ChartTimelineItems",e=>(function DependencyLinesItemsWrapper(t,n){const s=i.html`${t}${l.html()}`;return e(s,n)})),function destroy(){c.destroy(),l.destroy()}}}}));
//# sourceMappingURL=DependencyLines.plugin.min.js.map
