!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self).DependencyLines=t()}(this,(function(){"use strict";
/**
   * DependencyLines plugin
   *
   * @copyright Rafal Pospiech <https://neuronet.io>
   * @author    Rafal Pospiech <neuronet.io@gmail.com>
   * @package   gantt-schedule-timeline-calendar
   * @license   GPL-3.0 (https://github.com/neuronetio/gantt-schedule-timeline-calendar/blob/master/LICENSE)
   * @link      https://github.com/neuronetio/gantt-schedule-timeline-calendar
   */let e,t,n;const s=document.createElement("div");s.style.position="absolute",s.style.left="0",s.style.top="0",s.style.width="var(--width)",s.style.height="var(--height)";const i={type:"quadratic",style:{},width:16,height:16};function DependencyLinesLines(e){const{html:t,onDestroy:n,api:s,state:i,reuseComponents:o}=e;let c;n(i.subscribe("config.classNames",()=>{c=s.getClass("chart-timeline-dependency-lines-lines")}));let r=[];return n(i.subscribe("_internal.chart.visibleItems",e=>{const t=i.get("config.list.rows"),n={};for(const s in e){const i=e[s];"string"==typeof i.rowId&&t[i.rowId]&&(n[i.rowId]=t[i.rowId])}})),e=>t`
      <div class="${c}">${r.map(e=>e.html())}</div>
    `}function ItemDependencyLineHandle(t,n){const{html:s,onDestroy:i,api:o,state:c,StyleMap:r,onChange:a,Detach:l,update:p,Actions:d,PointerAction:m}=t,u=Object.assign({},n);let h;i(c.subscribe("config.classNames",()=>{h=o.getClass("chart-timeline-dependency-lines-handle")}));let f=!1;const y=new l(()=>f),g=new r({left:"0px",top:"0px",width:e.width+"px",height:e.height+"px"});function updatePosition(){g.style.left=o.time.globalTimeToViewPixelOffset(n.item.time.end,!0)-e.width+"px",g.style.top=n.row.top+"px"}a((function change(e,t){if(t.leave)return f=!0,p();f=!1,n=e;for(const e in n)u[e]=n[e];updatePosition(),p()})),i(c.subscribeAll(["_internal.chart.time","config.scroll.compensation"],()=>{updatePosition(),p()}));const v=o.getActions("chart-timeline-dependency-lines-handle")||[];let w=!1;u.pointerOptions={axis:"xy",onDown({event:e}){e.stopPropagation(),e.preventDefault(),w=!0},onMove({event:e,movementX:t,movementY:n}){w&&(e.stopPropagation(),e.preventDefault(),console.log("move?",{movementX:t,movementY:n}))}},v.push(m);const b=d.create(v,u);return e=>s`
      <div detach=${y} class=${h} style=${g} data-actions=${b}></div>
    `}function DependencyLinesHandles(e){const{html:t,onDestroy:n,api:s,state:i,reuseComponents:o}=e;let c;n(i.subscribe("config.classNames",()=>{c=s.getClass("chart-timeline-dependency-lines-handles")}));const r=[];return n(i.subscribe("_internal.chart.visibleItems",e=>{const t=[],n=i.get("config.list.rows");for(const s of e){const e=n[s.rowId];e&&t.push({item:s,row:e})}return o(r,t,e=>e,ItemDependencyLineHandle)})),e=>t`
      <div class="${c}">${r.map(e=>e.html())}</div>
    `}return function DependencyLinesPlugin(s=i){return e=Object.assign(Object.assign({},i),s),function initialize(e){t=e.state,n=e.api;const s=e.createComponent(DependencyLinesLines);t.update("config.wrappers.ChartTimelineGrid",t=>(function DependencyLinesGridWrapper(n,i){const o=e.html`${n}${s.html()}`;return t(o,i)}));const i=e.createComponent(DependencyLinesHandles);return t.update("config.wrappers.ChartTimelineItems",t=>(function DependencyLinesItemsWrapper(n,s){const o=e.html`${n}${i.html()}`;return t(o,s)})),function destroy(){s.destroy(),i.destroy()}}}}));
//# sourceMappingURL=DependencyLines.plugin.min.js.map
