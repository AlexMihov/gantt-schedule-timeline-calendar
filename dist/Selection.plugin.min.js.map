{"version":3,"file":"Selection.plugin.min.js","sources":["../src/plugins/Selection.plugin.ts"],"sourcesContent":["/**\n * Selection plugin\n *\n * @copyright Rafal Pospiech <https://neuronet.io>\n * @author    Rafal Pospiech <neuronet.io@gmail.com>\n * @package   gantt-schedule-timeline-calendar\n * @license   GPL-3.0 (https://github.com/neuronetio/gantt-schedule-timeline-calendar/blob/master/LICENSE)\n * @link      https://github.com/neuronetio/gantt-schedule-timeline-calendar\n */\n\nexport interface RectStyle {\n  [key: string]: any;\n}\n\nexport interface Options {\n  grid?: boolean;\n  items?: boolean;\n  rows?: boolean;\n  horizontal?: boolean;\n  vertical?: boolean;\n  rectStyle?: RectStyle;\n  selecting?: (data, type: string) => void;\n  deselecting?: (data, type: string) => void;\n  selected?: (data, type) => void;\n  deselected?: (data, type) => void;\n  canSelect?: (type, state, all) => any[];\n  canDeselect?: (type, state, all) => any[];\n  getApi?: (api: any) => void;\n}\n\nexport interface Items {\n  [key: string]: string[];\n}\n\ninterface SelectingData {\n  fromX?: number;\n  fromY?: number;\n  toX?: number;\n  toY?: number;\n  startX?: number;\n  startY?: number;\n  startCell?: any;\n  selecting?: boolean;\n  selected?: Items;\n}\n\nexport interface SelectState {\n  selecting?: Items;\n  selected?: Items;\n}\n\nexport default function Selection(options: Options = {}) {\n  let vido, state, api, schedule;\n  const path = 'config.plugin.selection';\n  const rectClassName = 'gantt-schedule-timeline-caledar__plugin-selection-rect';\n  const rect = document.createElement('div');\n  rect.classList.add(rectClassName);\n  rect.style.visibility = 'hidden';\n  rect.style.left = '0px';\n  rect.style.top = '0px';\n  rect.style.width = '0px';\n  rect.style.height = '0px';\n  rect.style.background = 'rgba(0, 119, 192, 0.2)';\n  rect.style.border = '2px dashed rgba(0, 119, 192, 0.75)';\n  rect.style.position = 'absolute';\n  rect.style['user-select'] = 'none';\n  rect.style['pointer-events'] = 'none';\n\n  const defaultOptions: Options = {\n    grid: false,\n    items: true,\n    rows: false,\n    horizontal: true,\n    vertical: true,\n    rectStyle: {},\n    selecting() {},\n    deselecting() {},\n    selected() {},\n    deselected() {},\n    canSelect(type, currently, all) {\n      return currently;\n    },\n    canDeselect(type, currently, all) {\n      return [];\n    },\n    getApi() {}\n  };\n  options = { ...defaultOptions, ...options } as Options;\n  for (const styleProp in options.rectStyle) {\n    rect.style[styleProp] = options.rectStyle[styleProp];\n  }\n  let selecting: SelectingData = {\n    fromX: -1,\n    fromY: -1,\n    toX: -1,\n    toY: -1,\n    startX: -1,\n    startY: -1,\n    startCell: false,\n    selecting: false\n  };\n  const selectionTypesIdGetters = {\n    'chart-timeline-grid-row': props => props.row.id,\n    'chart-timeline-grid-row-block': props => props.id,\n    'chart-timeline-items-row': props => props.row.id,\n    'chart-timeline-items-row-item': props => props.item.id\n  };\n\n  /**\n   * Selection action class\n   */\n  class SelectionAction {\n    chartTimeline: Element;\n    mouseDown: (ev: MouseEvent) => void;\n    mouseMove: (ev: MouseEvent) => void;\n    mouseUp: (ev: MouseEvent) => void;\n    left: number;\n    top: number;\n\n    /**\n     * Selection action constructor\n     * @param {Element} element\n     * @param {object|any} data\n     */\n    constructor(element: Element, data: any) {\n      let previousSelect,\n        api = {} as any;\n      this.chartTimeline = state.get('_internal.elements.chart-timeline');\n      if (!this.chartTimeline.querySelector('.' + rectClassName)) {\n        this.chartTimeline.insertAdjacentElement('beforeend', rect);\n        const bounding = this.chartTimeline.getBoundingClientRect();\n        this.left = bounding.left;\n        this.top = bounding.top;\n      }\n\n      /**\n       * Clear selection\n       * @param {boolean} force\n       */\n      function clearSelection(force: boolean = false) {\n        let selectingState;\n        state.update(path, currently => {\n          selectingState = {\n            selecting: {\n              'chart-timeline-grid-rows': [],\n              'chart-timeline-grid-row-blocks': [],\n              'chart-timeline-items-rows': [],\n              'chart-timeline-items-row-items': []\n            },\n            selected: {\n              'chart-timeline-grid-rows': force\n                ? []\n                : options.canDeselect(\n                    'chart-timeline-grid-rows',\n                    currently.selected['chart-timeline-grid-rows'],\n                    currently\n                  ),\n              'chart-timeline-grid-row-blocks': force\n                ? []\n                : options.canDeselect(\n                    'chart-timeline-grid-row-blocks',\n                    currently.selected['chart-timeline-grid-row-blocks'],\n                    currently\n                  ),\n              'chart-timeline-items-rows': force\n                ? []\n                : options.canDeselect(\n                    'chart-timeline-items-rows',\n                    currently.selected['chart-timeline-items-rows'],\n                    currently\n                  ),\n              'chart-timeline-items-row-items': force\n                ? []\n                : options.canDeselect(\n                    'chart-timeline-items-rows',\n                    currently.selected['chart-timeline-items-rows'],\n                    currently\n                  )\n            }\n          };\n          return selectingState;\n        });\n        state.update('_internal.chart.grid.rowsWithBlocks', function clearRowsWithBlocks(rowsWithBlocks) {\n          for (const row of rowsWithBlocks) {\n            for (const block of row.blocks) {\n              block.selected = selectingState.selected['chart-timeline-grid-row-blocks'].includes(block.id);\n              block.selecting = false;\n            }\n          }\n          return rowsWithBlocks;\n        });\n      }\n      api.clearSelection = clearSelection;\n\n      /**\n       * Clone current selection state\n       * @param {object} currentSelect\n       * @returns {object} currentSelect cloned\n       */\n      function cloneSelection(currentSelect) {\n        const result: SelectingData = {};\n        result.selecting = { ...currentSelect.selecting };\n        result.selecting['chart-timeline-grid-rows'] = currentSelect.selecting['chart-timeline-grid-rows'].slice();\n        result.selecting['chart-timeline-grid-row-blocks'] = currentSelect.selecting[\n          'chart-timeline-grid-row-blocks'\n        ].slice();\n        result.selecting['chart-timeline-items-rows'] = currentSelect.selecting['chart-timeline-items-rows'].slice();\n        result.selecting['chart-timeline-items-row-items'] = currentSelect.selecting[\n          'chart-timeline-items-row-items'\n        ].slice();\n        result.selected = { ...currentSelect.selected };\n        result.selected['chart-timeline-grid-rows'] = currentSelect.selected['chart-timeline-grid-rows'].slice();\n        result.selected['chart-timeline-grid-row-blocks'] = currentSelect.selected[\n          'chart-timeline-grid-row-blocks'\n        ].slice();\n        result.selected['chart-timeline-items-rows'] = currentSelect.selected['chart-timeline-items-rows'].slice();\n        result.selected['chart-timeline-items-row-items'] = currentSelect.selected[\n          'chart-timeline-items-row-items'\n        ].slice();\n        return result;\n      }\n\n      /**\n       * Save and swap coordinates if needed\n       * @param {MouseEvent} ev\n       */\n      const saveAndSwapIfNeeded = (ev: MouseEvent) => {\n        const currentX = ev.x - this.left;\n        const currentY = ev.y - this.top;\n        if (currentX <= selecting.startX) {\n          selecting.fromX = currentX;\n          selecting.toX = selecting.startX;\n        } else {\n          selecting.fromX = selecting.startX;\n          selecting.toX = currentX;\n        }\n        if (currentY <= selecting.startY) {\n          selecting.fromY = currentY;\n          selecting.toY = selecting.startY;\n        } else {\n          selecting.fromY = selecting.startY;\n          selecting.toY = currentY;\n        }\n      };\n\n      /**\n       * Is rectangle inside other rectangle ?\n       * @param {DOMRect} boundingRect\n       * @param {DOMRect} rectBoundingRect\n       * @returns {boolean}\n       */\n      const isInside = (boundingRect: DOMRect, rectBoundingRect: DOMRect) => {\n        let horizontal = false;\n        let vertical = false;\n        if (\n          (boundingRect.left > rectBoundingRect.left && boundingRect.left < rectBoundingRect.right) ||\n          (boundingRect.right > rectBoundingRect.left && boundingRect.right < rectBoundingRect.right) ||\n          (boundingRect.left <= rectBoundingRect.left && boundingRect.right >= rectBoundingRect.right)\n        ) {\n          horizontal = true;\n        }\n        if (\n          (boundingRect.top > rectBoundingRect.top && boundingRect.top < rectBoundingRect.bottom) ||\n          (boundingRect.bottom > rectBoundingRect.top && boundingRect.bottom < rectBoundingRect.bottom) ||\n          (boundingRect.top <= rectBoundingRect.top && boundingRect.bottom >= rectBoundingRect.bottom)\n        ) {\n          vertical = true;\n        }\n        return horizontal && vertical;\n      };\n\n      /**\n       * Get selecting elements\n       * @param {DOMRect} rectBoundingRect\n       * @param {Element[]} elements\n       * @param {string} type\n       * @returns {string[]}\n       */\n      const getSelecting = (rectBoundingRect: DOMRect, elements: Element[], type: string, getId: (any) => string) => {\n        const selectingResult = [];\n        const currentlySelectingData = [];\n        const all = elements[type + 's'];\n        const currentAll = state.get(path);\n        const currentSelecting = currentAll.selecting[type + 's'];\n        for (const element of all) {\n          const boundingRect = element.getBoundingClientRect();\n          if (isInside(boundingRect, rectBoundingRect)) {\n            currentlySelectingData.push(element.vido);\n            const canSelect = options.canSelect(type, currentlySelectingData, currentAll);\n            if (canSelect.includes(element.vido)) {\n              if (!currentSelecting.includes(getId(element.vido))) {\n                options.selecting(element.vido, type);\n              }\n              selectingResult.push(getId(element.vido));\n            } else {\n              currentlySelectingData.unshift();\n            }\n          } else {\n            if (currentSelecting.includes(getId(element.vido))) {\n              options.deselecting(element.vido, type);\n            }\n          }\n        }\n        return selectingResult;\n      };\n\n      /**\n       * Select\n       * @param {Event} ev\n       */\n      const select = ev => {\n        if (!selecting.selecting) {\n          return;\n        }\n        clearSelection();\n        saveAndSwapIfNeeded(ev);\n        rect.style.left = selecting.fromX + 'px';\n        rect.style.top = selecting.fromY + 'px';\n        rect.style.visibility = 'visible';\n        rect.style.width = selecting.toX - selecting.fromX + 'px';\n        rect.style.height = selecting.toY - selecting.fromY + 'px';\n        const rectBoundingRect = rect.getBoundingClientRect();\n        const elements = state.get('_internal.elements');\n        const nowSelecting = {};\n        for (const type in selectionTypesIdGetters) {\n          nowSelecting[type + 's'] = getSelecting(rectBoundingRect, elements, type, selectionTypesIdGetters[type]);\n        }\n\n        state.update(`${path}.selecting`, nowSelecting);\n\n        state.update(\n          'config.chart.items',\n          function updateItems(items) {\n            const now = nowSelecting['chart-timeline-items-row-items'];\n            for (const itemId in items) {\n              const item = items[itemId];\n              if (now.includes(item.id)) {\n                item.selecting = true;\n              } else {\n                item.selecting = false;\n              }\n            }\n            return items;\n          },\n          { only: ['selecting'] }\n        );\n\n        state.update('_internal.chart.grid.rowsWithBlocks', function updateRowsWithBlocks(rowsWithBlocks) {\n          const nowBlocks = nowSelecting['chart-timeline-grid-row-blocks'];\n          const nowRows = nowSelecting['chart-timeline-grid-rows'];\n          for (const row of rowsWithBlocks) {\n            if (nowRows.includes(row.id)) {\n              row.selecting = true;\n            } else {\n              row.selecting = false;\n            }\n            for (const block of row.blocks) {\n              if (nowBlocks.includes(block.id)) {\n                block.selecting = true;\n              } else {\n                block.selecting = false;\n              }\n            }\n          }\n          return rowsWithBlocks;\n        });\n      };\n\n      /**\n       * End select\n       * @param {Event} ev\n       */\n      const endSelect = ev => {\n        if (selecting.selecting) {\n          ev.stopPropagation();\n          if (selecting.fromX === ev.x - this.left && selecting.fromY === ev.y - this.top) {\n            selecting.selecting = false;\n            rect.style.visibility = 'hidden';\n            return;\n          }\n        } else {\n          clearSelection();\n          return;\n        }\n\n        selecting.selecting = false;\n        rect.style.visibility = 'hidden';\n        const currentSelect = state.get(path);\n        const select: SelectState = {};\n        state.update(path, value => {\n          select.selected = { ...value.selecting };\n          select.selecting = {\n            'chart-timeline-grid-rows': [],\n            'chart-timeline-grid-row-blocks': [],\n            'chart-timeline-items-rows': [],\n            'chart-timeline-items-row-items': []\n          } as Items;\n          return select;\n        });\n        const elements = state.get('_internal.elements');\n        for (const type in selectionTypesIdGetters) {\n          for (const element of elements[type + 's']) {\n            if (currentSelect.selecting[type + 's'].includes(element.vido.id)) {\n              options.deselecting(element.vido, type);\n            }\n          }\n        }\n        state.update('config.chart.items', function updateItems(items) {\n          const now = currentSelect.selecting['chart-timeline-items-row-items'];\n          for (const itemId in items) {\n            const item = items[itemId];\n            if (now.includes(item.id)) {\n              item.selecting = true;\n            } else {\n              item.selecting = false;\n            }\n          }\n          return items;\n        });\n        state.update('_internal.chart.grid.rowsWithBlocks', function updateRowsWithBlocks(rowsWithBlocks) {\n          for (const row of rowsWithBlocks) {\n            for (const block of row.blocks) {\n              if (currentSelect.selecting['chart-timeline-grid-row-blocks'].includes(block.id)) {\n                if (typeof block.selected === 'undefined' || !block.selected) {\n                  options.selected(block, 'chart-timeline-grid-row-block');\n                }\n                block.selected = true;\n              } else {\n                if (previousSelect.selected['chart-timeline-grid-row-blocks'].includes(block.id)) {\n                  options.deselected(block, 'chart-timeline-grid-row-block');\n                }\n                block.selected = false;\n              }\n            }\n          }\n          return rowsWithBlocks;\n        });\n      };\n\n      /**\n       * Mouse down event handler\n       * @param {MouseEvent} ev\n       */\n      this.mouseDown = ev => {\n        if (ev.button !== 0) {\n          return;\n        }\n        selecting.selecting = true;\n        selecting.fromX = ev.x - this.left;\n        selecting.fromY = ev.y - this.top;\n        selecting.startX = selecting.fromX;\n        selecting.startY = selecting.fromY;\n        previousSelect = cloneSelection(state.get(path));\n        clearSelection();\n      };\n\n      /**\n       * Mouse move event handler\n       * @param {MouseEvent} ev\n       */\n      this.mouseMove = ev => {\n        select(ev);\n      };\n\n      /**\n       * Mouse up event handler\n       * @param {MouseEvent} ev\n       */\n      this.mouseUp = ev => {\n        if (selecting.selecting) {\n          endSelect(ev);\n        }\n      };\n\n      element.addEventListener('mousedown', this.mouseDown);\n      document.addEventListener('mousemove', schedule(this.mouseMove));\n      document.addEventListener('mouseup', this.mouseUp);\n      options.getApi(api);\n    }\n    update() {\n      const bounding = this.chartTimeline.getBoundingClientRect();\n      this.left = bounding.left;\n      this.top = bounding.top;\n    }\n    destroy(element) {\n      document.removeEventListener('mouseup', this.mouseUp);\n      document.removeEventListener('mousemove', this.mouseMove);\n      element.removeEventListener('mousedown', this.mouseDown);\n    }\n  }\n\n  /**\n   * Update selection\n   * @param {any} data\n   * @param {HTMLElement} element\n   * @param {string[]} selecting\n   * @param {string[]} selected\n   * @param {string} classNameSelecting\n   * @param {string} classNameSelected\n   */\n  function updateSelection(\n    element: HTMLElement,\n    selecting: string[],\n    selected: string[],\n    classNameSelecting: string,\n    classNameSelected: string\n  ) {\n    if (selecting && !element.classList.contains(classNameSelecting)) {\n      element.classList.add(classNameSelecting);\n    } else if (!selecting && element.classList.contains(classNameSelecting)) {\n      element.classList.remove(classNameSelecting);\n    }\n    if (selected && !element.classList.contains(classNameSelected)) {\n      element.classList.add(classNameSelected);\n    } else if (!selected && element.classList.contains(classNameSelected)) {\n      element.classList.remove(classNameSelected);\n    }\n  }\n\n  /**\n   * Grid row block action\n   * @param {HTMLElement} element\n   * @param {object} data\n   * @returns {object} with update and destroy functions\n   */\n  class GridBlockAction {\n    classNameSelecting: string;\n    classNameSelected: string;\n\n    constructor(element: HTMLElement, data: any) {\n      this.classNameSelecting = api.getClass('chart-timeline-grid-row-block') + '--selecting';\n      this.classNameSelected = api.getClass('chart-timeline-grid-row-block') + '--selected';\n      updateSelection(element, data.selecting, data.selected, this.classNameSelecting, this.classNameSelected);\n    }\n\n    update(element: HTMLElement, data: any) {\n      updateSelection(element, data.selecting, data.selected, this.classNameSelecting, this.classNameSelected);\n    }\n\n    destroy(element: Element, changedData: any) {\n      element.classList.remove(this.classNameSelecting);\n      element.classList.remove(this.classNameSelected);\n    }\n  }\n\n  /**\n   * Item action\n   * @param {Element} element\n   * @param {object} data\n   * @returns {object} with update and destroy functions\n   */\n  class ItemAction {\n    classNameSelecting: string;\n    classNameSelected: string;\n\n    constructor(element: HTMLElement, data: any) {\n      this.classNameSelecting = api.getClass('chart-timeline-items-row-item') + '--selecting';\n      this.classNameSelected = api.getClass('chart-timeline-items-row-item') + '--selected';\n      updateSelection(\n        element,\n        data.item.selecting,\n        data.item.selected,\n        this.classNameSelecting,\n        this.classNameSelected\n      );\n    }\n\n    update(element: HTMLElement, data: any) {\n      updateSelection(\n        element,\n        data.item.selecting,\n        data.item.selected,\n        this.classNameSelecting,\n        this.classNameSelected\n      );\n    }\n\n    destroy(element: HTMLElement, data: any) {\n      element.classList.remove(this.classNameSelecting);\n      element.classList.remove(this.classNameSelected);\n    }\n  }\n\n  /**\n   * On block create handler\n   * @param {object} block\n   * @returns {object} block\n   */\n  function onBlockCreate(block) {\n    const selectedBlocks = state.get('config.plugin.selection.selected.chart-timeline-grid-row-blocks');\n    for (const selectedBlock of selectedBlocks) {\n      if (selectedBlock === block.id) {\n        block.selected = true;\n        return block;\n      }\n    }\n    block.selected = false;\n    block.selecting = false;\n    return block;\n  }\n\n  return function initialize(mainVido) {\n    vido = mainVido;\n    state = vido.state;\n    api = vido.api;\n    schedule = vido.schedule;\n    if (typeof state.get(path) === 'undefined') {\n      state.update(path, {\n        selecting: {\n          'chart-timeline-grid-rows': [],\n          'chart-timeline-grid-row-blocks': [],\n          'chart-timeline-items-rows': [],\n          'chart-timeline-items-row-items': []\n        },\n        selected: {\n          'chart-timeline-grid-rows': [],\n          'chart-timeline-grid-row-blocks': [],\n          'chart-timeline-items-rows': [],\n          'chart-timeline-items-row-items': []\n        }\n      });\n    }\n    state.update('config.chart.items', items => {\n      for (const itemId in items) {\n        const item = items[itemId];\n        if (typeof item.selecting === 'undefined') {\n          item.selecting = false;\n        }\n        if (typeof item.selected === 'undefined') {\n          item.selected = false;\n        }\n      }\n      return items;\n    });\n    state.update('config.actions.chart-timeline', actions => {\n      actions.push(SelectionAction);\n      return actions;\n    });\n    state.update('config.actions.chart-timeline-grid-row-block', actions => {\n      actions.push(GridBlockAction);\n      return actions;\n    });\n    state.update('config.actions.chart-timeline-items-row-item', actions => {\n      actions.push(ItemAction);\n      return actions;\n    });\n    state.update('config.chart.grid.block.onCreate', onCreate => {\n      onCreate.push(onBlockCreate);\n      return onCreate;\n    });\n  };\n}\n"],"names":["Selection","options","vido","state","api","schedule","path","rectClassName","rect","document","createElement","classList","add","style","visibility","left","top","width","height","background","border","position","defaultOptions","grid","items","rows","horizontal","vertical","rectStyle","[object Object]","canSelect","type","currently","all","canDeselect","Object","styleProp","selecting","fromX","fromY","toX","toY","startX","startY","startCell","selectionTypesIdGetters","chart-timeline-grid-row","props","row","id","chart-timeline-grid-row-block","chart-timeline-items-row","chart-timeline-items-row-item","item","SelectionAction","element","data","previousSelect","this","chartTimeline","get","querySelector","insertAdjacentElement","bounding","getBoundingClientRect","clearSelection","force","selectingState","update","chart-timeline-grid-rows","chart-timeline-grid-row-blocks","chart-timeline-items-rows","chart-timeline-items-row-items","selected","clearRowsWithBlocks","rowsWithBlocks","block","blocks","includes","saveAndSwapIfNeeded","ev","currentX","x","currentY","y","isInside","boundingRect","rectBoundingRect","right","bottom","getSelecting","elements","getId","selectingResult","currentlySelectingData","currentAll","currentSelecting","push","unshift","deselecting","endSelect","stopPropagation","currentSelect","select","value","updateItems","now","itemId","updateRowsWithBlocks","deselected","mouseDown","button","cloneSelection","result","slice","mouseMove","nowSelecting","only","nowBlocks","nowRows","mouseUp","addEventListener","getApi","removeEventListener","updateSelection","classNameSelecting","classNameSelected","contains","remove","GridBlockAction","getClass","changedData","ItemAction","onBlockCreate","selectedBlocks","selectedBlock","initialize","mainVido","actions","onCreate"],"mappings":"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"}